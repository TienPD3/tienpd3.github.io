<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>日本語文法クイズ</title>
    <style>
        body {
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .quiz-container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .question-block {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .question-block:last-child {
            border-bottom: none;
        }
        .question-text {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .options {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .option {
            background: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .option:hover {
            background: #f0f0f0;
        }
        .option.correct {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
            font-weight: bold;
        }
        .option.incorrect {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }
        .option.disabled {
            pointer-events: none;
            opacity: 0.8;
        }
        .translation {
            display: none;
            font-style: italic;
            color: #666;
            margin-left: 8px;
            font-weight: normal;
        }
        .question-block.answered .translation {
            display: inline;
        }

        .question-block.hidden {
            display: none;
        }

        .navigation-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .navigation-controls button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ddd;
            background-color: #f0f0f0;
        }

        .navigation-controls button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .mode-toggle {
            display: flex;
            align-items: center;
        }
        .mode-toggle label {
            margin-left: 5px;
        }
        h1 {
            text-align: center;
            color: #444;
        }
    </style>
</head>
<body>

    <h1>日本語文法クイズ</h1>

    <div class="filter-controls" style="margin-bottom: 20px; padding: 10px; background: #f0f0f0; border-radius: 5px; display: flex; flex-wrap: wrap; align-items: center; gap: 10px;">
        <label for="start-range">Từ:</label>
        <input type="number" id="start-range" min="1" value="1" style="width: 60px; padding: 5px;">
        <label for="end-range">Đến:</label>
        <input type="number" id="end-range" style="width: 60px; padding: 5px;">
        <button id="filter-btn" style="padding: 5px 10px;">Lọc</button>
        <button id="reset-btn" style="padding: 5px 10px; margin-left: 5px; background-color: #f8d7da; border-color: #f5c6cb;">Bắt đầu lại</button>
        <div style="display: flex; align-items: center; margin-left: 10px;">
            <input type="checkbox" id="randomize-questions-checkbox">
            <label for="randomize-questions-checkbox">Trộn câu hỏi</label>
        </div>
        <span id="total-questions-info" style="margin-left: 10px;"></span>
        <button id="review-incorrect-btn" style="padding: 5px 10px; margin-left: 10px; background-color: #ffc107; border-color: #ffc107;">Xem lại câu sai</button>
        <span id="score-info" style="margin-left: 10px; font-weight: bold;"></span>
    </div>

    <div id="quiz-container"></div>

    <div class="navigation-controls">
        <button id="prev-btn">Previous</button>
        <span id="question-counter"></span>
        <button id="next-btn">Next</button>
        <div class="mode-toggle">
            <input type="checkbox" id="cumulative-mode-checkbox">
            <label for="cumulative-mode-checkbox">Lặp lại</label>
        </div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let cumulativeMaxIndex = 0;
        let isCumulativeMode = false;
        let originalQuizData = [];
        let activeQuizData = [];
        let userAnswers = {};
        let isReviewMode = false;
        let preReviewActiveQuizData = [];

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function saveState() {
            // Capture the shuffled order of options for questions that have been seen
            activeQuizData.forEach((q, index) => {
                if (isReviewMode) return; // Don't save option order changes in review mode
                const questionBlock = document.getElementById(`question-${index}`);
                if (questionBlock && questionBlock.classList.contains('seen')) {
                    const originalIndex = originalQuizData.indexOf(q);
                    if (!userAnswers[originalIndex]) userAnswers[originalIndex] = {};
                    
                    const optionsList = questionBlock.querySelector('.options');
                    const options = Array.from(optionsList.children);
                    userAnswers[originalIndex].optionOrder = options.map(opt => opt.textContent.split(' (')[0]);
                }
            });

            const isRandomized = document.getElementById('randomize-questions-checkbox').checked;
            const state = {
                currentQuestionIndex: isReviewMode ? 0 : currentQuestionIndex,
                cumulativeMaxIndex,
                isCumulativeMode,
                startRange: document.getElementById('start-range').value,
                endRange: document.getElementById('end-range').value,
                userAnswers,
                isRandomized,
                questionOrder: isRandomized ? activeQuizData.map(q => originalQuizData.indexOf(q)) : null,
            };
            localStorage.setItem('grammaQuizState', JSON.stringify(state));
        }

        function loadState(savedStateJSON) {
            const state = JSON.parse(savedStateJSON);

            currentQuestionIndex = state.currentQuestionIndex || 0;
            cumulativeMaxIndex = state.cumulativeMaxIndex || 0;
            isCumulativeMode = state.isCumulativeMode || false;
            userAnswers = state.userAnswers || {};

            document.getElementById('start-range').value = state.startRange;
            document.getElementById('end-range').value = state.endRange;
            document.getElementById('cumulative-mode-checkbox').checked = isCumulativeMode;
            document.getElementById('randomize-questions-checkbox').checked = state.isRandomized || false;

            let start = parseInt(state.startRange) - 1;
            let end = parseInt(state.endRange);

            if (state.isRandomized && state.questionOrder && state.questionOrder.length > 0) {
                activeQuizData = state.questionOrder.map(index => originalQuizData[index]).filter(Boolean);
            } else {
                activeQuizData = originalQuizData.slice(start, end);
            }

            renderQuiz();

            // Apply saved states to the DOM - for seen and option order
            activeQuizData.forEach((q, index) => {
                const originalIndex = originalQuizData.indexOf(q);
                const questionState = userAnswers[originalIndex];
                if (!questionState) return;

                const questionBlock = document.getElementById(`question-${index}`);
                if (questionState.seen) {
                    questionBlock.classList.add('seen');
                    // Restore shuffled order
                    if (questionState.optionOrder) {
                        const optionsList = questionBlock.querySelector('.options');
                        const optionElements = Array.from(optionsList.children);
                        const sortedElements = questionState.optionOrder.map(text => 
                            optionElements.find(el => el.textContent.split(' (')[0] === text)
                        ).filter(Boolean);
                        
                        if (sortedElements.length === optionElements.length) {
                             sortedElements.forEach(el => optionsList.appendChild(el));
                        }
                    }
                }
                // The answered styling is now handled by renderQuiz
            });

            if (activeQuizData.length > 0) {
                setupNavigation();
                showQuestion(currentQuestionIndex);
                calculateScore(); // To show score on load
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            fetch('../assets/storage/gramma_quiz.json')
                .then(response => response.json())
                .then(data => {
                    originalQuizData = data;
                    initializeFilterControls();

                    const savedStateJSON = localStorage.getItem('grammaQuizState');
                    if (savedStateJSON) {
                        loadState(savedStateJSON);
                    } else {
                        // Manually trigger filter to get initial activeQuizData
                        document.getElementById('filter-btn').click();
                    }
                })
                .catch(error => {
                    console.error('Error fetching quiz data:', error);
                    document.getElementById('quiz-container').innerHTML = '<p style="color: red;">クイズデータの読み込みに失敗しました。</p>';
                });
        });

        function calculateScore() {
            let correctCount = 0;
            let incorrectCount = 0;
            let answeredCount = 0;
            
            const dataSet = isReviewMode ? preReviewActiveQuizData : activeQuizData;

            dataSet.forEach(q => {
                const originalIndex = originalQuizData.indexOf(q);
                const answerInfo = userAnswers[originalIndex];

                if (answerInfo && answerInfo.answered) {
                    answeredCount++;
                    const correctAnswer = q.correctAnswer;
                    if (answerInfo.selection === correctAnswer) {
                        correctCount++;
                    } else {
                        incorrectCount++;
                    }
                }
            });
            
            const scoreInfo = document.getElementById('score-info');
            if (scoreInfo) {
                if (answeredCount > 0) {
                    scoreInfo.textContent = `Đúng: ${correctCount}, Sai: ${incorrectCount} (Tổng: ${answeredCount})`;
                } else {
                    scoreInfo.textContent = '';
                }
            }
        }

        function toggleReviewMode() {
            isReviewMode = !isReviewMode;
            const reviewBtn = document.getElementById('review-incorrect-btn');
            const filterBtn = document.getElementById('filter-btn');
            const startRange = document.getElementById('start-range');
            const endRange = document.getElementById('end-range');
            const randomizeCheckbox = document.getElementById('randomize-questions-checkbox');
            
            if (isReviewMode) {
                // Disable filter controls
                filterBtn.disabled = true;
                startRange.disabled = true;
                endRange.disabled = true;
                randomizeCheckbox.disabled = true;

                preReviewActiveQuizData = [...activeQuizData]; 

                const incorrectQuestions = preReviewActiveQuizData.filter(q => {
                    const originalIndex = originalQuizData.indexOf(q);
                    const answerInfo = userAnswers[originalIndex];
                    return answerInfo && answerInfo.answered && answerInfo.selection !== q.correctAnswer;
                });

                if (incorrectQuestions.length === 0) {
                    alert('Không có câu trả lời sai nào để xem lại.');
                    isReviewMode = false; // back to normal
                    // Re-enable filter controls
                    filterBtn.disabled = false;
                    startRange.disabled = false;
                    endRange.disabled = false;
                    randomizeCheckbox.disabled = false;
                    return;
                }
                
                reviewBtn.textContent = 'Quay lại Quiz';
                reviewBtn.style.backgroundColor = '#28a745';
                reviewBtn.style.borderColor = '#28a745';

                activeQuizData = incorrectQuestions;
                startQuiz();
            } else {
                // Re-enable filter controls
                filterBtn.disabled = false;
                startRange.disabled = false;
                endRange.disabled = false;
                randomizeCheckbox.disabled = false;

                reviewBtn.textContent = 'Xem lại câu sai';
                reviewBtn.style.backgroundColor = '#ffc107';
                reviewBtn.style.borderColor = '#ffc107';

                activeQuizData = preReviewActiveQuizData;
                startQuiz();
            }
        }

        function initializeFilterControls() {
            const startRange = document.getElementById('start-range');
            const endRange = document.getElementById('end-range');
            const filterBtn = document.getElementById('filter-btn');
            const resetBtn = document.getElementById('reset-btn');
            const totalInfo = document.getElementById('total-questions-info');
            const reviewBtn = document.getElementById('review-incorrect-btn');

            reviewBtn.addEventListener('click', toggleReviewMode);


            totalInfo.textContent = `(Tổng: ${originalQuizData.length} câu)`;
            startRange.max = originalQuizData.length;
            if(!endRange.value) endRange.value = originalQuizData.length;
            endRange.max = originalQuizData.length;

            filterBtn.addEventListener('click', () => {
                const wasCumulative = document.getElementById('cumulative-mode-checkbox').checked;
                const shouldRandomize = document.getElementById('randomize-questions-checkbox').checked;

                let start = parseInt(startRange.value) - 1;
                let end = parseInt(endRange.value);

                if (isNaN(start) || start < 0 || start >= originalQuizData.length) {
                    start = 0;
                    startRange.value = 1;
                }
                if (isNaN(end) || end > originalQuizData.length || end < start + 1) {
                    end = originalQuizData.length;
                    endRange.value = end;
                }
                
                activeQuizData = originalQuizData.slice(start, end);

                if (shouldRandomize) {
                    shuffleArray(activeQuizData);
                }
                
                userAnswers = {}; // Reset answers on new filter
                startQuiz();

                if (wasCumulative) {
                    const newCheckbox = document.getElementById('cumulative-mode-checkbox');
                    newCheckbox.checked = true;
                    newCheckbox.dispatchEvent(new Event('change'));
                }
            });

            resetBtn.addEventListener('click', () => {
                if (confirm('Bạn có chắc muốn xoá toàn bộ tiến trình và bắt đầu lại?')) {
                    localStorage.removeItem('grammaQuizState');
                    isReviewMode = false;
                    location.reload();
                }
            });
        }

        function startQuiz() {
            currentQuestionIndex = 0;
            cumulativeMaxIndex = 0;
            const cumulativeCheckbox = document.getElementById('cumulative-mode-checkbox');
            cumulativeCheckbox.checked = false;
            cumulativeCheckbox.disabled = isReviewMode;
            isCumulativeMode = false;
            
            renderQuiz();
            if (activeQuizData.length > 0) {
                setupNavigation();
                showQuestion(currentQuestionIndex);
            }
            saveState(); // Save the initial state of the new quiz
        }

        function resetAllQuestions() {
            document.querySelectorAll('.question-block').forEach(block => {
                block.classList.remove('answered', 'seen');
                block.querySelectorAll('.option').forEach(option => {
                    option.classList.remove('disabled', 'correct', 'incorrect');
                });
            });
            
            activeQuizData.forEach(q => {
                const originalIndex = originalQuizData.indexOf(q);
                if (userAnswers[originalIndex]) {
                    delete userAnswers[originalIndex].answered;
                    delete userAnswers[originalIndex].selection;
                }
            });
            saveState();
            calculateScore();
            renderQuiz(); // re-render to apply changes
            showQuestion(currentQuestionIndex);
        }

        function setupNavigation() {
            document.querySelector('.navigation-controls').style.display = 'flex';
            const nextBtn = document.getElementById('next-btn');
            const prevBtn = document.getElementById('prev-btn');
            const cumulativeModeCheckbox = document.getElementById('cumulative-mode-checkbox');
            
            const newNextBtn = nextBtn.cloneNode(true);
            nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
            const newPrevBtn = prevBtn.cloneNode(true);
            prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
            const newCumulativeModeCheckbox = cumulativeModeCheckbox.cloneNode(true);
            cumulativeModeCheckbox.parentNode.replaceChild(newCumulativeModeCheckbox, cumulativeModeCheckbox);
            newCumulativeModeCheckbox.disabled = isReviewMode;

            newCumulativeModeCheckbox.addEventListener('change', (e) => {
                if (isReviewMode) return;
                isCumulativeMode = e.target.checked;
                resetAllQuestions();
                if (isCumulativeMode) {
                    cumulativeMaxIndex = currentQuestionIndex;
                    currentQuestionIndex = 0;
                } else {
                    currentQuestionIndex = cumulativeMaxIndex;
                }
                showQuestion(currentQuestionIndex);
                saveState();
            });

            newNextBtn.addEventListener('click', () => {
                if (isCumulativeMode) {
                    if (currentQuestionIndex === cumulativeMaxIndex) {
                        if (cumulativeMaxIndex < activeQuizData.length - 1) {
                            cumulativeMaxIndex++;
                        }
                        currentQuestionIndex = 0;
                        resetAllQuestions();
                    } else {
                        currentQuestionIndex++;
                    }
                } else {
                    if (currentQuestionIndex < activeQuizData.length - 1) {
                        currentQuestionIndex++;
                    }
                }
                showQuestion(currentQuestionIndex);
                saveState();
            });

            newPrevBtn.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    showQuestion(currentQuestionIndex);
                }
                saveState();
            });
        }
        
        function showQuestion(index) {
            document.querySelectorAll('.question-block').forEach((block, i) => {
                block.classList.toggle('hidden', i !== index);
            });
            
            const questionBlock = document.getElementById(`question-${index}`);
            if (questionBlock && !questionBlock.classList.contains('seen')) {
                questionBlock.classList.add('seen');
                
                const q = activeQuizData[index];
                const originalIndex = originalQuizData.indexOf(q);
                if (!userAnswers[originalIndex]) userAnswers[originalIndex] = {};
                userAnswers[originalIndex].seen = true;

                if (!isReviewMode) {
                    const optionsList = questionBlock.querySelector('.options');
                    if (optionsList) {
                        const options = Array.from(optionsList.children);
                        shuffleArray(options);
                        options.forEach(option => optionsList.appendChild(option));
                    }
                }
            }
            
            currentQuestionIndex = index;

            const nextBtn = document.getElementById('next-btn');
            const prevBtn = document.getElementById('prev-btn');
            const counter = document.getElementById('question-counter');

            prevBtn.disabled = index === 0;

            let isAtEnd;
            if (isReviewMode) {
                isAtEnd = index === activeQuizData.length - 1;
            } else if (isCumulativeMode) {
                 isAtEnd = index === cumulativeMaxIndex && cumulativeMaxIndex === activeQuizData.length - 1;
            } else {
                isAtEnd = index === activeQuizData.length - 1;
            }
            nextBtn.disabled = isAtEnd;
            
            if (isCumulativeMode) {
                counter.textContent = `Question ${index + 1} of ${cumulativeMaxIndex + 1} (Review)`;
            } else if (isReviewMode) {
                counter.textContent = `Câu sai ${index + 1}/${activeQuizData.length}`;
            } else {
                counter.textContent = `Question ${index + 1} of ${activeQuizData.length}`;
            }
        }

        function renderQuiz() {
            const quizContainer = document.getElementById('quiz-container');
            quizContainer.innerHTML = '';

            if (activeQuizData.length === 0) {
                quizContainer.innerHTML = isReviewMode
                    ? '<p>Chúc mừng! Bạn không có câu sai nào để xem lại.</p>'
                    : '<p>Không có câu hỏi nào trong khoảng đã chọn.</p>';
                document.querySelector('.navigation-controls').style.display = 'none';
                return;
            }

            activeQuizData.forEach((q, index) => {
                const questionBlock = document.createElement('div');
                questionBlock.className = 'question-block hidden';
                questionBlock.id = `question-${index}`;

                const questionText = document.createElement('p');
                questionText.className = 'question-text';
                const cleanQuestion = q.question.replace(/^\d+[\.．\s]*/, '');
                const displayIndex = originalQuizData.indexOf(q) + 1;
                const formattedQuestion = cleanQuestion.replace(/\n/g, '<br/>');
                questionText.innerHTML = `${displayIndex}. ${formattedQuestion}`;
                
                if (q.translation && q.translation.question) {
                    const translationSpan = document.createElement('span');
                    translationSpan.className = 'translation';
                    const formattedTranslation = q.translation.question.replace(/\n/g, '<br/>');
                    translationSpan.innerHTML = `(${formattedTranslation})`;
                    questionText.appendChild(translationSpan);
                }
                questionBlock.appendChild(questionText);

                const optionsList = document.createElement('ul');
                optionsList.className = 'options';

                // Use saved order in review mode or for answered questions
                const originalIndex = originalQuizData.indexOf(q);
                const questionState = userAnswers[originalIndex];
                let optionOrder = q.options;
                if (questionState && questionState.optionOrder && (isReviewMode || questionState.answered)) {
                    // Create a stable order based on the saved one
                    let savedOrder = questionState.optionOrder;
                    optionOrder = [...savedOrder, ...q.options.filter(o => !savedOrder.includes(o))];
                }


                optionOrder.forEach(option => {
                    const optionItem = document.createElement('li');
                    optionItem.className = 'option';
                    optionItem.textContent = option;

                    if (q.translation && q.translation.options && q.translation.options[option]) {
                        const translationSpan = document.createElement('span');
                        translationSpan.className = 'translation';
                        translationSpan.textContent = ` (${q.translation.options[option]})`;
                        optionItem.appendChild(translationSpan);
                    }
                    
                    optionItem.addEventListener('click', () => {
                        if (isReviewMode) return; // Disable answering in review mode

                        const questionBlock = optionItem.closest('.question-block');
                        if (questionBlock.classList.contains('answered')) return;
                        questionBlock.classList.add('answered');

                        const originalIndexOfQ = originalQuizData.indexOf(q);
                        if (!userAnswers[originalIndexOfQ]) userAnswers[originalIndexOfQ] = {};
                        userAnswers[originalIndexOfQ].answered = true;
                        userAnswers[originalIndexOfQ].selection = option.split(' (')[0];

                        const parentOptions = optionItem.parentElement;
                        Array.from(parentOptions.children).forEach(child => child.classList.add('disabled'));

                        if (option === q.correctAnswer) {
                            optionItem.classList.add('correct');
                        } else {
                            optionItem.classList.add('incorrect');
                            Array.from(parentOptions.children).forEach(child => {
                                if (child.textContent.split(' (')[0] === q.correctAnswer) {
                                    child.classList.add('correct');
                                }
                            });
                        }
                        saveState();
                        calculateScore();
                    });
                    optionsList.appendChild(optionItem);
                });

                questionBlock.appendChild(optionsList);
                quizContainer.appendChild(questionBlock);

                if (questionState && questionState.answered) {
                    questionBlock.classList.add('answered');
                    const options = questionBlock.querySelectorAll('.option');
                    options.forEach(optionItem => {
                        const optionText = optionItem.textContent.split(' (')[0];
                        if (isReviewMode || questionState.selection) {
                            optionItem.classList.add('disabled');
                        }
                        if (optionText === q.correctAnswer) {
                            optionItem.classList.add('correct');
                        }
                        if (optionText === questionState.selection && optionText !== q.correctAnswer) {
                            optionItem.classList.add('incorrect');
                        }
                    });
                }
            });
        }
    </script>

</body>
</html>
