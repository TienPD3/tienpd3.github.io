<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Quiz Tr·∫Øc Nghi·ªám - Udemy Style</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="../css/web/quiz.css" />
</head>
<body>

<button id="darkModeToggle" style="position: fixed; top: 10px; left: 10px; z-index: 3000; padding: 8px 12px; border-radius: 5px; border: none; background-color: #007bff; color: white; cursor: pointer;">Toggle Dark Mode</button>

<div id="quizStatusBar">
    ƒê√£ l√†m 0/0 c√¢u | ƒê√∫ng 0 | Sai 0
</div>

<div class="container">
    <h2>Tr·∫Øc Nghi·ªám Business Analysis</h2>

    <!-- C√†i ƒë·∫∑t Quiz -->
    <div class="settings">
        <div id="categoryRadio" style="margin-bottom: 10px;">
            <!-- Radio categories s·∫Ω load ·ªü ƒë√¢y -->
        </div>
        <div class="dropdown-checkbox" id="dropdownCheckboxWrapper">
            <button type="button" id="dropdownButton" aria-haspopup="true" aria-expanded="false">Ch·ªçn file JSON</button>
            <div class="dropdown-content" id="dropdownContent">
                <div id="fileListCheckboxes">
                    <!-- Checkbox files s·∫Ω load ·ªü ƒë√¢y -->
                </div>
            </div>
        </div>

        <br />

        <!-- <label><input type="checkbox" id="showVocabulary" checked> Hi·ªÉn th·ªã Vocabulary</label> -->
        <!-- <br /> -->

        <label>T·ª´ c√¢u:</label>
        <input type="number" id="startQuestion" value="0" step="5" min="0" style="width: 50px;">

        <label>ƒê·∫øn c√¢u:</label>
        <input type="number" id="endQuestion" value="" step="5" min="5" style="width: 50px;">
        <br>

        <label>S·ªë c√¢u h·ªèi ng·∫´u nhi√™n:</label>
        <input type="number" id="randomQuestionCount" value="5" step="5" min="0" style="width: 50px;">
        <br>

        <label><input type="radio" name="order" value="ordered" checked> Theo th·ª© t·ª±</label>
        <label><input type="radio" name="order" value="random"> Ng·∫´u nhi√™n</label>
        <br>

        <label><input type="radio" name="shuffleAnswersOption" value="normal" checked> Ng·∫´u nhi√™n d·ªÖ</label>
        <label><input type="radio" name="shuffleAnswersOption" value="basedOnCorrect"> Ng·∫´u nhi√™n kh√≥</label>
    </div>

    <button class="btn" id="startQuiz">B·∫Øt ƒë·∫ßu</button>
    <button class="btn" id="retrySavedWrong">L√†m l·∫°i c√¢u sai ƒë√£ l∆∞u</button>
    
    <div id="quizContainer" style="display: none;">
        <div id="quiz"></div>
        <div class="leftButtonGroup">
            <button class="btn" id="resetting">C√†i ƒë·∫∑t</button>
            <button class="btn" id="retest">L√†m l·∫°i</button>
        </div>
        <div class="rightButtonGroup">
            <button class="btn hidden" id="retryWrong">L√†m l·∫°i c√¢u sai</button>
            <button class="btn" id="submitQuiz">N·ªôp b√†i</button>
            <button class="btn" id="continueQuiz">L√†m ti·∫øp</button>
        </div>
    </div>
</div>
<div id="toast" style="display: none;"></div>

<script>
    let questions = [];
    let selectedQuestions = [];
    let allFileNames = [];
    let wrongQuestions = [];  // Th√™m bi·∫øn to√†n c·ª•c n·∫øu c·∫ßn
    let savedWrongQuestions = [];

    // Load saved wrong questions from localStorage with dynamic chunking
    function loadSavedWrongQuestions() {
        savedWrongQuestions = [];
        let index = 0;
        while (true) {
            const key = `savedWrongQuestions_${index}`;
            let chunk = null;
            try {
                chunk = localStorage.getItem(key);
                if (!chunk) break;
                const parsed = JSON.parse(chunk);
                if (Array.isArray(parsed)) {
                    // Ensure each question has correctCount property
                    parsed.forEach(q => {
                        if (typeof q.correctCount !== 'number') {
                            q.correctCount = 0;
                        }
                    });
                    savedWrongQuestions = savedWrongQuestions.concat(parsed);
                }
            } catch (e) {
                console.error(`L·ªói khi ph√¢n t√≠ch ${key}:`, e);
                break;
            }
            index++;
        }
    }

    // Save wrong questions to localStorage with dynamic chunking and quota handling
    function saveWrongQuestionsToLocalStorage() {
        // Clear all previous chunks first
        let index = 0;
        while (true) {
            const key = `savedWrongQuestions_${index}`;
            if (localStorage.getItem(key) === null) break;
            localStorage.removeItem(key);
            index++;
        }

        // Try to save in chunks, reducing chunk size if quota exceeded
        let chunkSize = 50; // initial chunk size
        let start = 0;
        while (start < savedWrongQuestions.length) {
            let end = Math.min(start + chunkSize, savedWrongQuestions.length);
            let chunk = savedWrongQuestions.slice(start, end);
            let key = `savedWrongQuestions_${Math.floor(start / chunkSize)}`;
            try {
                localStorage.setItem(key, JSON.stringify(chunk));
                start = end;
            } catch (e) {
                if (chunkSize === 1) {
                    console.error('L·ªói khi l∆∞u savedWrongQuestions, d·ªØ li·ªáu qu√° l·ªõn ƒë·ªÉ l∆∞u:', e);
                    break;
                }
                // Reduce chunk size and retry
                chunkSize = Math.floor(chunkSize / 2);
                if (chunkSize < 1) chunkSize = 1;
                start = 0; // restart saving with smaller chunk size
            }
        }
    }

    // Add or update question in savedWrongQuestions with correctCount tracking
    function addToSavedWrongQuestions(questionObj) {
        let existing = savedWrongQuestions.find(q => q.question === questionObj.question);
        if (!existing) {
            questionObj.correctCount = 0;
            savedWrongQuestions.push(questionObj);
        }
        saveWrongQuestionsToLocalStorage();
    }

    // Remove question from savedWrongQuestions by question text
    function removeFromSavedWrongQuestions(questionObj) {
        const index = savedWrongQuestions.findIndex(q => q.question === questionObj.question);
        if (index !== -1) {
            savedWrongQuestions.splice(index, 1);
            saveWrongQuestionsToLocalStorage();
        }
    }
    let dataFileJson = [];
    let vocabularyData = {};
    let vocabularyLoaded = false;

    // Load vocabulary JSON and build dictionary
    function loadVocabulary() {
        return $.getJSON('../file/vocabulary/3000-english.json')
            .then(data => {
                data.forEach(item => {
                    if (item.Word && item.Meaning) {
                        vocabularyData[item.Word.toLowerCase()] = item.Meaning;
                    }
                });
                vocabularyLoaded = true;
            })
            .catch(err => {
                console.error('Error loading vocabulary JSON:', err);
                vocabularyLoaded = false;
            });
    }

    // Function to wrap English words with Vietnamese meaning as small text above
    function wrapWithMeaning(text) {
        if (!vocabularyLoaded) return text;

        if (!$("#showVocabulary").prop("checked")) {
            return text;
        }

        // Split text into words and non-words to preserve punctuation
        const parts = text.split(/(\W+)/);

        const wrappedParts = parts.map(part => {
            const lowerPart = part.toLowerCase();
            if (vocabularyData[lowerPart]) {
                // Get the meaning string
                let meaning = vocabularyData[lowerPart];
                // Split meaning by ',' or ';' and trim
                let meaningsArray = meaning.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                // Pick a random meaning from the array
                let randomMeaning = meaningsArray[Math.floor(Math.random() * meaningsArray.length)];
                // Determine if the word is long to add class for letter spacing
                let longWordClass = "";
                if (part.length > 10) { // threshold for long word
                    longWordClass = "long-word";
                }
                // Wrap with span and small text above with random meaning
                return `<span class="vocab-word ${longWordClass}" title="${randomMeaning}">${part}<small class="vocab-meaning">${randomMeaning}</small></span>`;
            } else {
                return part;
            }
        });

        return wrappedParts.join('');
    }

    $(function() {
        // Load vocabulary first, then load options and restore settings
        loadVocabulary().then(() => {
            loadOptions();
            restoreSettingsFromLocalStorage();
            setupDropdownEvents();

            // Disable or enable shuffleAnswersOption based on order selection
            function updateShuffleAnswersOptionState() {
                const orderValue = $("input[name='order']:checked").val();
                if (orderValue === "ordered") {
                    $("input[name='shuffleAnswersOption']").prop("disabled", true);
                } else {
                    $("input[name='shuffleAnswersOption']").prop("disabled", false);
                }
            }

            // Initial call on page load
            updateShuffleAnswersOptionState();

            // Listen for changes on order radio buttons
            $(document).on("change", "input[name='order']", function() {
                updateShuffleAnswersOptionState();
            });
        });
    });

    function updateQuizStatusBar() {
        let total = selectedQuestions.length;
        let done = 0;    // s·ªë c√¢u ƒë√£ ch·ªçn ƒë√°p √°n
        let correctCount = 0;
        let wrongCount = 0;

        selectedQuestions.forEach((q, index) => {
            let userAnswer = $(`input[name='q${index}']:checked`).val();
            if (userAnswer) {
                done++;
                if (userAnswer === q.correct_answer) {
                    correctCount++;
                } else {
                    wrongCount++;
                }
            }
        });

        let start = parseInt($("#startQuestion").val()) || 1;
        let end = parseInt($("#endQuestion").val()) || questions.length;

        $("#quizStatusBar").text(`ƒê√£ l√†m (${start} ~ ${end}) ${done}/${total} c√¢u | ƒê√∫ng ${correctCount} | Sai ${wrongCount}`);

        if (total > 0) {
            $("#quizStatusBar").show();
        } else {
            $("#quizStatusBar").hide();
        }
    }

    function saveSettingsToLocalStorage() {
        localStorage.setItem('quizSettings', JSON.stringify({
            categoryNames: $("input[name='categoryFilter']:checked").map(function () { return this.value }).get(),
            fileNames: $("input[name='jsonFiles']:checked").map(function () { return this.value }).get(),
            startQuestion: $("#startQuestion").val(),
            endQuestion: $("#endQuestion").val(),
            randomQuestionCount: $("#randomQuestionCount").val(),
            order: $("input[name='order']:checked").val(),
            shuffleAnswersOption: $("input[name='shuffleAnswersOption']:checked").val()
        }));
    }

    $(document).on("change input", "#startQuestion, #endQuestion, #randomQuestionCount, input[name='order'], input[name='shuffleAnswersOption'], input[name='categoryFilter']", saveSettingsToLocalStorage);

    function restoreSettingsFromLocalStorage() {
        const saved = localStorage.getItem('quizSettings');
        if (saved) {
            const settings = JSON.parse(saved);
            $("#startQuestion").val(settings.startQuestion);
            $("#endQuestion").val(settings.endQuestion);
            $("#randomQuestionCount").val(settings.randomQuestionCount);
            $(`input[name='order'][value='${settings.order}']`).prop("checked", true);
            if (settings.shuffleAnswersOption) {
                $(`input[name='shuffleAnswersOption'][value='${settings.shuffleAnswersOption}']`).prop("checked", true);
            }

            // Sau khi checkbox load xong s·∫Ω set checked theo settings
            setTimeout(() => {
                if (settings.categoryNames && settings.categoryNames.length > 0) {
                    $("input[name='categoryFilter']").each(function () {
                        this.checked = settings.categoryNames.includes(this.value);
                    });
                }

                renderFileCheckboxes();

                $("input[name='jsonFiles']").each(function () {
                    if (settings.fileNames.includes(this.value)) {
                        this.checked = true;
                    }
                });
                updateDropdownButtonText();
            }, 500);
        }
    }

    let endQuenstionInit = 5;
    let isInit = true;
    $("#startQuiz").click(function () {
        let selectedFiles = $("input[name='jsonFiles']:checked").map(function () {
            return this.value;
        }).get();

        if (selectedFiles.length === 0) {
            showToast("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt file JSON!");
            return;
        }
        wrongQuestions = [];
        $("#retryWrong").hide();
        Promise.all(selectedFiles.map(f => $.getJSON(`../file/quiz/${f}`)))
            .then(fileDataList => {
                questions = fileDataList.flat();
                if (questions.length === 0) {
                    showToast("Kh√¥ng c√≥ c√¢u h·ªèi n√†o!");
                    return;
                }

                let start = parseInt($("#startQuestion").val()) || 0;
                let end = parseInt($("#endQuestion").val()) || questions.length;
                if (isInit) {
                    isInit = false;
                    endQuenstionInit = end;
                }

                if (start == 0) {
                    start = 1;
                }

                if (start < 1 || end > questions.length || start > end) {
                    showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questions.length} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                    $('#continueQuiz').hide();
                    return;
                }

                let isRandom = $("input[name='order']:checked").val() === "random";
                selectedQuestions = questions.slice(start - 1, end);
                
                if (isRandom) {
                    selectedQuestions = selectedQuestions.sort(() => Math.random() - 0.5);
                    let questionCount = Math.min(
                        parseInt($("#randomQuestionCount").val()) || selectedQuestions.length,
                        selectedQuestions.length
                    );
                    selectedQuestions = selectedQuestions.slice(0, questionCount);
                }

                renderQuiz();
                $("#quizContainer").show();
                $('.settings').hide();
                $('#startQuiz').hide();
                $('#retrySavedWrong').hide();
                let numberQuestion = (end - start) + 1;
                $("#continueQuiz").text(`L√†m ti·∫øp ${numberQuestion} c√¢u ti·∫øp`);

            })
            .catch((e) => {
                console.error(e);
                showToast("L·ªói khi load file JSON!");
            });
    });

    function renderQuiz() {
        $("#quiz").empty();
        selectedQuestions.forEach((q, index) => {

            let tmpNo = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];

            // B·ªè qua c√¢u h·ªèi n·∫øu thi·∫øu d·ªØ li·ªáu quan tr·ªçng
            if (!q.options || !q.correct_answer) {
                console.warn(`‚ö†Ô∏è B·ªè qua c√¢u h·ªèi ${index + 1}: thi·∫øu options ho·∫∑c correct_answer.`);
                return;
            }

            let optionsArray = Object.entries(q.options).filter(item => item[1] !== '');

            // Determine shuffle mode
            let shuffleMode = $("input[name='shuffleAnswersOption']:checked").val();

            // Ki·ªÉm tra n·∫øu ƒë√°p √°n ƒë√∫ng l√† "All of the above"
            const isAllOfTheAbove = optionsArray.some(option => option[1] === "All of the above" && option[0] === q.correct_answer);

            if (shuffleMode === "normal" || isAllOfTheAbove) {
                optionsArray.sort(() => Math.random() - 0.5);
            } else if (shuffleMode === "basedOnCorrect") {
                // Collect all correct answers and their texts from other questions
                let otherCorrectOptions = [];

                selectedQuestions.forEach((item, idx) => {
                    if (idx !== index && item.correct_answer && item.options && item.options[item.correct_answer]) {
                        otherCorrectOptions.push({ key: tmpNo[otherCorrectOptions.length], value: item.options[item.correct_answer] });
                    }
                });

                // Add current question's correct answer
                let currentCorrectKey = q.correct_answer;
                let currentCorrectValue = q.options[currentCorrectKey];
                otherCorrectOptions = otherCorrectOptions.filter(option => option.key !== q.correct_answer);
                otherCorrectOptions.push({ key: currentCorrectKey, value: currentCorrectValue });
                
                // Remove duplicates by value
                let uniqueOptionsMap = {};
                otherCorrectOptions.forEach(opt => {
                    uniqueOptionsMap[opt.value] = opt;
                });
                let uniqueOptions = Object.values(uniqueOptionsMap);

                // Randomly select up to 4 options (or less if not enough)
                let maxOptions = Math.min(4, uniqueOptions.length);
                let selectedOptions = [];

                while (selectedOptions.length < maxOptions) {
                    let randIndex = Math.floor(Math.random() * uniqueOptions.length);
                    let option = uniqueOptions.splice(randIndex, 1)[0];
                    option.key = tmpNo[selectedOptions.length];
                    selectedOptions.push(option);
                }

                // Ensure current correct answer is included
                if (!selectedOptions.some(opt => opt.key === currentCorrectKey)) {
                    selectedOptions.pop();
                    selectedOptions.push({ key: currentCorrectKey, value: currentCorrectValue });
                }

                // Shuffle final options
                selectedOptions.sort(() => Math.random() - 0.5);

                optionsArray = selectedOptions.map(opt => [opt.key, opt.value]);
            }

            let idxNo = -1;
            let optionsHtml = "";

            $.each(optionsArray, function (tmpKey, tmpValue) {
                let key = tmpValue[0];
                let value = tmpValue[1];

                idxNo++;
                let isLast = (idxNo === optionsArray.length - 1);

                // Determine if question or answer text is long to add class for spacing
                let questionLongClass = "";
                if (q.question.length > 50) {
                    questionLongClass = "long-vocab";
                }
                let answerLongClass = "";
                if (value.length > 50) {
                    answerLongClass = "long-vocab";
                }

                optionsHtml += `
                    <div data-index="${index}" style="display: flex; align-items: center; justify-content: space-between;">
                        <label style="flex: 1;" class="${answerLongClass}">
                            <input type="radio" name="q${index}" value="${key}">
                            ${tmpNo[idxNo]}. ${wrapWithMeaning(value)}
                        </label>
                        ${isLast ? `
                            <button class="btn check-answer" data-index="${index}" style="padding: 6px 12px; font-size: 14px;">Ki·ªÉm tra</button>
                            <span class="tooltip-wrapper" style="position: relative; display: inline-block;">
                                <span class="explain-tooltip-icon disabled-tooltip" title="Xem gi·∫£i th√≠ch" data-index="${index}"
                                    style="display:none; cursor:pointer; font-size: 18px; color: #007bff;">üí°</span>
                                <div class="explain-tooltip-content">
                                    ${q.explanation || "Ch∆∞a c√≥ gi·∫£i th√≠ch."}
                                </div>
                            </span>
                        ` : ''}
                    </div>
                `;
            });

            // Check if there is an image to display
            let imageHtml = q.image ? `<img src="${q.image}" alt="Question Image" style="max-width: 100%; height: auto; margin-top: 10px;">` : '';

            // Add long-vocab class to question div if question text is long
            let questionClass = "";
            if (q.question.length > 50) {
                questionClass = "long-vocab";
            }

            let correctCountDisplay = "";
            let savedWrongEntry = savedWrongQuestions.find(entry => entry.question === q.question);
            if (savedWrongEntry) {
                correctCountDisplay = `<span id="spnCorrectCount" title="L·∫ßn ƒë√∫ng li√™n ti·∫øp" style="display: inline-block; background-color: green; color: white; border-radius: 50%; width: 20px; height: 20px; line-height: 20px; text-align: center; font-weight: bold; margin-left: 10px; font-size: 12px;">${savedWrongEntry.correctCount}</span>`;
            }
            $("#quiz").append(`
                <div class="question ${questionClass}" style="position: relative;">
                    ${index + 1}. ${wrapWithMeaning(q.question)} ${correctCountDisplay}
                    <span class="translate-icon" data-index="${index}" title="D·ªãch c√¢u h·ªèi" 
                        style="cursor:pointer; margin-left:10px; font-size:18px; color:#007bff;">üîÑ</span>
                    <span class="chatgpt-icon" data-index="${index}" title="H·ªèi ChatGPT"
                        style="cursor:pointer; margin-left:10px; font-size:18px; color:#28a745;">ü§ñ</span>
                    <div class="translation" style="color: #555; margin-top: 5px; display:none;"></div>
                    ${imageHtml}
                </div>
                <div class="options">${optionsHtml}</div>
                <hr>
            `);
        });
        updateQuizStatusBar();
    }

    // B·∫Øt s·ª± ki·ªán click icon ChatGPT - copy prompt + m·ªü tab ChatGPT
    $(document).on('click', '.chatgpt-icon', function () {
        const index = $(this).data('index');
        const questionObj = selectedQuestions[index];

        let fullText = `1. D·ªãch v·ª´a c√≥ ti·∫øng anh v√† ti·∫øng vi·ªát\n`
        fullText += `2. Tr√≠ch d·∫´n t·ª´ BABOK V3 ·ªü c√¢u ƒë√∫ng\n`
        fullText += `C√¢u h·ªèi: ${questionObj.question}\n`;

        for (const key in questionObj.options) {
            fullText += `${key}. ${questionObj.options[key]}\n`;
        }

        fullText += `\nƒê√°p √°n c·ªßa t√¥i l√†: ${questionObj.correct_answer}`;

        // Copy v√†o clipboard
        navigator.clipboard.writeText(fullText)
            .then(() => {
                window.open("https://chatgpt.com/?temporary-chat=true", '_blank');
            })
            .catch(err => {
                showToast("Kh√¥ng th·ªÉ copy v√†o clipboard. Vui l√≤ng th·ª≠ l·∫°i.");
                console.error(err);
            });
    });

    // B·∫Øt s·ª± ki·ªán click icon d·ªãch
    $(document).on('click', '.translate-icon', function () {
        const index = $(this).data('index');
        const questionObj = selectedQuestions[index];

        // N·ªëi c√¢u h·ªèi + t·ª´ng ƒë√°p √°n th√†nh 1 chu·ªói
        let fullText = questionObj.question + '\n';
        for (const key in questionObj.options) {
            fullText += `${key}. ${questionObj.options[key]}\n`;
        }

        // M√£ h√≥a v√† m·ªü tab m·ªõi Google Translate
        const url = `https://translate.google.com/?sl=en&tl=vi&text=${encodeURIComponent(fullText)}&op=translate`;
        window.open(url, '_blank');
    });

    $(document).on("click", ".check-answer", function () {

        const index = $(this).data("index");
        const selected = $(`input[name='q${index}']:checked`).val();
        const correct = selectedQuestions[index].correct_answer;

        if (!selected) {
            showToast("Vui l√≤ng ch·ªçn m·ªôt ƒë√°p √°n tr∆∞·ªõc khi ki·ªÉm tra!");
            return;
        }

        $(`input[name='q${index}']`).prop("disabled", true);

        $(`input[name='q${index}'][value='${correct}']`).parent().addClass("correct");
        const questionObj = selectedQuestions[index];
        let savedWrongEntry = savedWrongQuestions.find(q => q.question === questionObj.question);

        if (selected !== correct) {
            $(`input[name='q${index}'][value='${selected}']`).parent().addClass("incorrect");
            // ‚ûï Th√™m c√¢u sai v√†o danh s√°ch n·∫øu ch∆∞a c√≥
            if (!wrongQuestions.includes(questionObj)) {
                wrongQuestions.push(questionObj);
            }
            // Th√™m c√¢u sai v√†o savedWrongQuestions ho·∫∑c reset correctCount n·∫øu ƒë√£ c√≥
            if (savedWrongEntry) {
                savedWrongEntry.correctCount = 0;
            } else {
                addToSavedWrongQuestions(questionObj);
            }
        } else {
            // N·∫øu tr·∫£ l·ªùi ƒë√∫ng, tƒÉng correctCount n·∫øu c√≥ trong savedWrongQuestions
            if (savedWrongEntry) {
                savedWrongEntry.correctCount++;
                $('#spnCorrectCount').text(`${savedWrongEntry.correctCount}`);
                if (savedWrongEntry.correctCount >= 3) {
                    // X√≥a c√¢u ƒë√∫ng kh·ªèi savedWrongQuestions n·∫øu ƒë·∫°t 3 l·∫ßn ƒë√∫ng li√™n ti·∫øp
                    removeFromSavedWrongQuestions(questionObj);
                    if (wrongQuestions.includes(questionObj)) {
                        const indexRemove = wrongQuestions.indexOf(questionObj);
                        wrongQuestions.splice(indexRemove, 1);
                    }

                    if (wrongQuestions.length == 0) {
                        $('#resetting').click();
                    }
                }
            }
            if (wrongQuestions.includes(questionObj)) {
                const indexRemove = wrongQuestions.indexOf(questionObj);
                wrongQuestions.splice(indexRemove, 1);
            }
        }

        saveWrongQuestionsToLocalStorage();
        updateQuizStatusBar();
        if (wrongQuestions.length > 0) {
            $("#retryWrong").show(); // Hi·ªán n√∫t "L√†m l·∫°i c√¢u sai"
        } else {
            $("#retryWrong").hide();
        }

        $(`.explain-tooltip-icon[data-index='${index}']`).show();

        $(this).hide();
    });

    $("#submitQuiz").click(function () {
        let score = 0;
        wrongQuestions = []; // Reset

        selectedQuestions.forEach((q, index) => {
            let userAnswer = $(`input[name='q${index}']:checked`).val();
            let correctAnswer = q.correct_answer;

            if (userAnswer === correctAnswer) {
                score++;
                $(`input[name='q${index}'][value='${correctAnswer}']`).parent().addClass("correct");
                // X√≥a c√¢u ƒë√∫ng kh·ªèi savedWrongQuestions n·∫øu c√≥
                removeFromSavedWrongQuestions(q);
            } else {
                $(`input[name='q${index}'][value='${correctAnswer}']`).parent().addClass("correct");
                if (userAnswer) {
                    $(`input[name='q${index}'][value='${userAnswer}']`).parent().addClass("incorrect");
                }
                wrongQuestions.push(q);
                // Th√™m c√¢u sai v√†o savedWrongQuestions
                addToSavedWrongQuestions(q);
            }
            $(`input[name='q${index}']`).prop("disabled", true);
        });

        updateQuizStatusBar();

        if (wrongQuestions.length > 0) {
            $("#retryWrong").show(); // Hi·ªán n√∫t "L√†m l·∫°i c√¢u sai"
        } else {
            showToast("B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng t·∫•t c·∫£ c√°c c√¢u h·ªèi üéâ");
        }
    });

    $("#resetting").click(function () {
        window.scrollTo(0, 0);
        $('.settings').show();
        $('#startQuiz').show();
        $('#quizContainer').hide();
        $('#retrySavedWrong').show();
        
    });

    function loadOptions() {
        let listFileName = `../file/quiz/data-file-name.json`;
        fetch(listFileName)
            .then(response => {
                if (!response.ok) throw new Error("Kh√¥ng t√¨m th·∫•y file JSON");
                return response.json();
            })
            .then(data => {
                const categoryContainer = document.getElementById('categoryRadio');
                const container = document.getElementById('fileListCheckboxes');
                container.innerHTML = `
                    <label><input type="checkbox" id="checkAllFiles"><em>Ch·ªçn t·∫•t c·∫£</em></label>
                `;
                allFileNames = data.map(u => u.value);
                dataFileJson = data;

                // Extract unique categories
                const categories = [...new Set(data.map(item => item.category))];

                // Render category checkboxes
                categoryContainer.innerHTML = '';
                categories.forEach(cat => {
                    const catRadio = document.createElement('input');
                    catRadio.type = 'radio';
                    catRadio.name = 'categoryFilter';
                    catRadio.value = cat;
                    catRadio.id = `cat_${cat.replace(/\s+/g, '_')}`;

                    const catLabel = document.createElement('label');
                    catLabel.htmlFor = catRadio.id;
                    catLabel.style.marginRight = '10px';
                    catLabel.appendChild(catRadio);
                    catLabel.append(` ${cat}`);

                    categoryContainer.appendChild(catLabel);
                });

                // Initial render of file checkboxes
                renderFileCheckboxes();

                // Add event listeners for category radios to filter files
                $(document).off('change', "input[name='categoryFilter']");
                $(document).on('change', "input[name='categoryFilter']", () => {
                    renderFileCheckboxes();
                });
            })
            .catch(err => {
                showToast("L·ªói khi t·∫£i file JSON: " + err.message);
            });
    }


    // Function to render file checkboxes filtered by selected category
    function renderFileCheckboxes() {
        const selectedCategory = document.querySelector("input[name='categoryFilter']:checked");
        const container = document.getElementById('fileListCheckboxes');
        container.innerHTML = `<label><input type="checkbox" id="checkAllFiles"><em>Ch·ªçn t·∫•t c·∫£</em></label>`;

        let filteredData = [];
        if (selectedCategory) {
            filteredData = dataFileJson.filter(item => item.category === selectedCategory.value);

            if (selectedCategory.value == "Japanese") {
                $("input[name='shuffleAnswersOption']").prop("disabled", true);
                $("input[value='basedOnCorrect']").prop("checked", true);
            } else {
                $("input[name='shuffleAnswersOption']").prop("disabled", false);
            }
        }

        filteredData.forEach(item => {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'jsonFiles';
            checkbox.value = item.value;
            checkbox.id = `chk_${item.value}`;

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.appendChild(checkbox);
            label.append(` ${item.key}`);

            container.appendChild(label);
        });

        // Add event listeners for file checkboxes
        document.getElementById('checkAllFiles').addEventListener('change', function () {
            const checkboxes = document.querySelectorAll("input[name='jsonFiles']");
            checkboxes.forEach(cb => cb.checked = this.checked);
            updateDropdownButtonText();
            saveSettingsToLocalStorage();
        });

        document.querySelectorAll("#fileListCheckboxes input[name='jsonFiles']").forEach(cb => {
            cb.addEventListener('change', function () {
                updateCheckAllState();
                updateDropdownButtonText();
                saveSettingsToLocalStorage();
            });
        });

        updateCheckAllState();
        updateDropdownButtonText();
    }

    $("#retryWrong").click(function () {
        if (wrongQuestions.length === 0) {
            showToast("Kh√¥ng c√≥ c√¢u sai ƒë·ªÉ l√†m l·∫°i.");
            return;
        }

        selectedQuestions = [...wrongQuestions]; // D√πng l·∫°i danh s√°ch sai
        renderQuiz();
        updateQuizStatusBar();
        $("#retryWrong").hide(); // ·∫®n n√∫t sau khi d√πng
    });

    // X·ª≠ l√Ω n√∫t l√†m l·∫°i c√¢u sai ƒë√£ l∆∞u
    let isRetrySavedWrongMode = false;

    $("#retrySavedWrong").click(function () {
        if (savedWrongQuestions.length === 0) {
            showToast("Kh√¥ng c√≥ c√¢u sai ƒë√£ l∆∞u ƒë·ªÉ l√†m l·∫°i.");
            return;
        }
        
        isRetrySavedWrongMode = true;

        let start = parseInt($("#startQuestion").val()) || 1;
        let end = parseInt($("#endQuestion").val()) || questions.length;

        $("#quizContainer").show();
        $('.settings').hide();
        $('#startQuiz').hide();
        let numberQuestion = (end - start) + 1;
        $("#continueQuiz").text(`L√†m ti·∫øp ${numberQuestion} c√¢u ti·∫øp`);

        selectedQuestions = [...savedWrongQuestions];
        renderQuiz();
        updateQuizStatusBar();
        $("#retrySavedWrong").hide(); // ·∫®n n√∫t sau khi d√πng
    });

    $("#retest").click(function () {
        if (isRetrySavedWrongMode) {
            // Retest retrySavedWrong questions
            selectedQuestions = [...savedWrongQuestions];
        } else {
            // Retest current selected questions
            selectedQuestions = selectedQuestions.slice();
        }
        renderQuiz();
        updateQuizStatusBar();
    });

    $("#resetting").click(function () {
        isRetrySavedWrongMode = false;
        window.scrollTo(0, 0);
        $('.settings').show();
        $('#startQuiz').show();
        $('#quizContainer').hide();
        if (savedWrongQuestions.length > 0) {
            $('#retrySavedWrong').show();
        } else {
            $('#retrySavedWrong').hide();
        }
    });

    // Hi·ªÉn th·ªã n√∫t l√†m l·∫°i c√¢u sai ƒë√£ l∆∞u n·∫øu c√≥ d·ªØ li·ªáu
    function updateRetrySavedWrongButton() {
        if (savedWrongQuestions.length > 0) {
            $("#retrySavedWrong").show();
        } else {
            $("#retrySavedWrong").hide();
        }
    }

    // G·ªçi h√†m update n√∫t khi load trang v√† sau m·ªói l·∫ßn l∆∞u/x√≥a c√¢u sai
    $(document).ready(function () {
        loadSavedWrongQuestions();
        updateRetrySavedWrongButton();
    });

    function updateCheckAllState() {
        const allCheckboxes = document.querySelectorAll("input[name='jsonFiles']");
        const checkedBoxes = document.querySelectorAll("input[name='jsonFiles']:checked");
        const checkAll = document.getElementById('checkAllFiles');
        if (checkedBoxes.length === allCheckboxes.length) {
            checkAll.checked = true;
            checkAll.indeterminate = false;
        } else if (checkedBoxes.length > 0) {
            checkAll.checked = false;
            checkAll.indeterminate = true;
        } else {
            checkAll.checked = false;
            checkAll.indeterminate = false;
        }
    }

    function updateDropdownButtonText() {
        const checkedBoxes = document.querySelectorAll("input[name='jsonFiles']:checked");
        const button = document.getElementById('dropdownButton');
        if (checkedBoxes.length === 0) {
            button.textContent = 'Ch·ªçn file JSON';
        } else if (checkedBoxes.length === 1) {
            button.textContent = checkedBoxes[0].parentNode.textContent.trim();
        } else {
            button.textContent = `ƒê√£ ch·ªçn ${checkedBoxes.length} file`;
        }
    }

    function setupDropdownEvents() {
        const dropdownButton = document.getElementById('dropdownButton');
        const dropdownContent = document.getElementById('dropdownContent');

        dropdownButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (dropdownContent.style.display === 'block') {
                dropdownContent.style.display = 'none';
                dropdownButton.setAttribute('aria-expanded', 'false');
            } else {
                dropdownContent.style.display = 'block';
                dropdownButton.setAttribute('aria-expanded', 'true');
            }
        });

        // ƒê√≥ng dropdown n·∫øu click ngo√†i
        document.addEventListener('click', () => {
            dropdownContent.style.display = 'none';
            dropdownButton.setAttribute('aria-expanded', 'false');
        });

        // NgƒÉn kh√¥ng cho dropdown ƒë√≥ng khi click trong n·ªôi dung
        dropdownContent.addEventListener('click', e => {
            e.stopPropagation();
        });
    }
    function showToast(message, duration = 3000) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.className = "show";
        toast.style.display = "block";

        setTimeout(() => {
            toast.className = toast.className.replace("show", "");
            toast.style.display = "none";
        }, duration);
    }
    $(document).on("mouseenter", ".explain-tooltip-icon", function () {
        if (!$(this).hasClass("disabled-tooltip")) {
            $(this).siblings(".explain-tooltip-content").show();
        }
    }).on("mouseleave", ".explain-tooltip-icon", function () {
        $(this).siblings(".explain-tooltip-content").hide();
    });

    // Dark mode toggle logic
    const darkModeToggle = document.getElementById('darkModeToggle');
    const body = document.body;

    // Load saved preference
    if (localStorage.getItem('darkMode') === 'enabled') {
        $('body').addClass('dark-mode')
    }

    $(document).on("click", "#darkModeToggle", function () {
        document.body.classList.toggle('dark-mode');
        if (document.body.classList.contains('dark-mode')) {
            localStorage.setItem('darkMode', 'enabled');
        } else {
            localStorage.setItem('darkMode', 'disabled');
        }
    });

    // New button "L√†m ti·∫øp" click handler
    $("#continueQuiz").click(function () {
        let start = parseInt($("#startQuestion").val()) || 1;
        let end = parseInt($("#endQuestion").val()) || questions.length;

        // Double the values
        start += endQuenstionInit;
        end += endQuenstionInit;

        if (start < 1 || end > questions.length || start > end) {
            showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questions.length} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
            $('#continueQuiz').hide();
            return;
        }

        // Update the input fields
        $("#startQuestion").val(start);
        $("#endQuestion").val(end);
        $("#continueQuiz").text(`L√†m ti·∫øp ${endQuenstionInit} c√¢u ti·∫øp`);

        // Trigger the quiz start logic similar to #startQuiz click
        $("#startQuiz").click();
    });
    
</script>
<style>
    .vocab-word {
        position: relative;
        display: inline-block;
        cursor: help;
        color: #28a745;
    }
    .vocab-meaning {
        position: absolute;
        top: -0.5em;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.5em;
        color: #555;
        white-space: nowrap;
        pointer-events: none;
        user-select: none;
        font-style: italic;
    }
/* .long-vocab {
    word-spacing: 0.5em;
    letter-spacing: 0.1em;
} */
</style>
</body>
</html>
