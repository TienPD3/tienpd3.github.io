<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Quiz Tr·∫Øc Nghi·ªám - Udemy Style</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script defer src="/website/scripts/kuroshiro/kuroshiro.min.js"></script>
    <script defer src="/website/scripts/kuroshiro/kuroshiro-analyzer-kuromoji.min.js"></script>
    <link rel="stylesheet" href="../css/web/quiz.css" />
</head>
<body>

<button id="darkModeToggle" style="position: fixed; top: 10px; left: 10px; z-index: 3000; padding: 8px 12px; border-radius: 5px; border: none; background-color: #007bff; color: white; cursor: pointer;">Toggle Dark Mode</button>

<div id="quizStatusBar">
    ƒê√£ l√†m 0/0 c√¢u | ƒê√∫ng 0 | Sai 0
</div>

<div class="container">
    <h2>Tr·∫Øc Nghi·ªám Business Analysis</h2>

    <!-- C√†i ƒë·∫∑t Quiz -->
    <div class="settings">
        <div id="categoryRadio" style="margin-bottom: 10px;">
            <!-- Radio categories s·∫Ω load ·ªü ƒë√¢y -->
        </div>
        <div class="dropdown-checkbox" id="dropdownCheckboxWrapper">
            <button type="button" id="dropdownButton" aria-haspopup="true" aria-expanded="false">Ch·ªçn file JSON</button>
            <div class="dropdown-content" id="dropdownContent">
                <div id="fileListCheckboxes">
                    <!-- Checkbox files s·∫Ω load ·ªü ƒë√¢y -->
                </div>
            </div>
        </div>

        <br />

        <label><input type="checkbox" id="showVocabulary" checked> Hi·ªÉn th·ªã Vocabulary</label>
        <br />

        <label>Th·ªùi gian l√†m b√†i (ph√∫t):</label>
        <input type="number" id="quizDuration" value="15" min="1" style="width: 50px;">
        <br>

        <label>T·ª´ c√¢u:</label>
        <input type="number" id="startQuestion" value="0" step="5" min="0" style="width: 50px;">

        <label>ƒê·∫øn c√¢u:</label>
        <input type="number" id="endQuestion" value="" step="5" min="5" style="width: 50px;">
        <br>

        <label>S·ªë c√¢u h·ªèi ng·∫´u nhi√™n:</label>
        <input type="number" id="randomQuestionCount" value="5" step="5" min="0" style="width: 50px;">
        <br>

        <label><input type="radio" name="order" value="ordered" checked> Theo th·ª© t·ª±</label>
        <label><input type="radio" name="order" value="random"> Ng·∫´u nhi√™n</label>
        <br>

        <label><input type="radio" name="shuffleAnswersOption" value="normal" checked> Ng·∫´u nhi√™n d·ªÖ</label>
        <label><input type="radio" name="shuffleAnswersOption" value="basedOnCorrect"> Ng·∫´u nhi√™n kh√≥</label>
    </div>

    <button class="btn" id="startQuiz">B·∫Øt ƒë·∫ßu</button>
    <button class="btn" id="retrySavedWrong">L√†m l·∫°i c√¢u sai ƒë√£ l∆∞u</button>
    <div id="timer" style="font-weight: bold; font-size: 18px; margin-top: 10px; display: none;">Th·ªùi gian c√≤n l·∫°i: <span id="timeRemaining">00:00</span></div>
    <div id="quizContainer" style="display: none;">
        <div id="quiz"></div>
        <div class="leftButtonGroup">
            <button class="btn" id="resetting">C√†i ƒë·∫∑t</button>
            <button class="btn" id="retest">L√†m l·∫°i</button>
        </div>
        <div class="rightButtonGroup">
            <button class="btn hidden" id="retryWrong">L√†m l·∫°i c√¢u sai</button>
            <button class="btn" id="submitQuiz">N·ªôp b√†i</button>
            <button class="btn" id="continueQuiz">L√†m ti·∫øp</button>
        </div>
    </div>
</div>
<div id="toast" style="display: none;"></div>

<script>
    let questions = [];
    let selectedQuestions = [];
    let allFileNames = [];
    let wrongQuestions = [];  // Th√™m bi·∫øn to√†n c·ª•c n·∫øu c·∫ßn
    let savedWrongQuestions = [];
    let quizTimer = null;
    let timeRemaining = 0;

    // Initialize kuroshiro instance once after document ready
    let kuroshiro;
    let kuroshiroInitPromise;

    $(document).ready(function() {
        kuroshiro = new Kuroshiro();
        kuroshiroInitPromise = kuroshiro.init(new KuromojiAnalyzer());
    });

    // Load saved wrong questions from localStorage with dynamic chunking
    function loadSavedWrongQuestions() {
        savedWrongQuestions = [];
        for (let index = 0; ; index++) {
            const key = `savedWrongQuestions_${index}`;
            let chunk = null;
            try {
                chunk = localStorage.getItem(key);
                if (!chunk) break;
                const parsed = JSON.parse(chunk);
                if (Array.isArray(parsed)) {
                    // Ensure each question has correctCount property
                    parsed.forEach(q => {
                        if (typeof q.correctCount !== 'number') {
                            q.correctCount = 0;
                        }
                    });
                    savedWrongQuestions.push(...parsed);
                }
            } catch (e) {
                console.error(`L·ªói khi ph√¢n t√≠ch ${key}:`, e);
                break;
            }
        }
    }

    // Save wrong questions to localStorage with dynamic chunking and quota handling
    function saveWrongQuestionsToLocalStorage() {
        // Clear all previous chunks first
        for (let index = 0; ; index++) {
            const key = `savedWrongQuestions_${index}`;
            if (localStorage.getItem(key) === null) break;
            localStorage.removeItem(key);
        }

        // Try to save in chunks, reducing chunk size if quota exceeded
        let chunkSize = 50; // initial chunk size
        let start = 0;
        while (start < savedWrongQuestions.length) {
            let end = Math.min(start + chunkSize, savedWrongQuestions.length);
            let chunk = savedWrongQuestions.slice(start, end);
            let key = `savedWrongQuestions_${Math.floor(start / chunkSize)}`;
            try {
                localStorage.setItem(key, JSON.stringify(chunk));
                start = end;
            } catch (e) {
                if (chunkSize === 1) {
                    console.error('L·ªói khi l∆∞u savedWrongQuestions, d·ªØ li·ªáu qu√° l·ªõn ƒë·ªÉ l∆∞u:', e);
                    break;
                }
                // Reduce chunk size and retry
                chunkSize = Math.floor(chunkSize / 2);
                if (chunkSize < 1) chunkSize = 1;
                // Do not reset start to 0 to avoid infinite loop
                // Instead, continue with smaller chunk size from current start
            }
        }
    }

    // Function to compare index, example implementation
    function compareOptions(lstObjA, lstObjB) {
        if (!Array.isArray(lstObjA) || !Array.isArray(lstObjB)) return false;
        if (lstObjA.length !== lstObjB.length) return false;
        for (let i = 0; i < lstObjA.length; i++) {
            if (lstObjA[i] !== lstObjB[i]) {
                return false;
            }
        }
        return true;
    }

    // Add or update question in savedWrongQuestions with correctCount tracking
    function addToSavedWrongQuestions(questionObj) {
        let existing = savedWrongQuestions.find(q => 
            q.question === questionObj.question &&
            q.correct_answer === questionObj.correct_answer &&
            compareOptions(q.options, questionObj.options)
        );

        if (!existing) {
            // Clone questionObj to avoid mutating original object
            let newQuestion = Object.assign({}, questionObj);
            newQuestion.correctCount = 0;
            savedWrongQuestions.push(newQuestion);
            saveWrongQuestionsToLocalStorage();
        }
    }

    
    // Remove question from savedWrongQuestions by question text
    function removeFromSavedWrongQuestions(questionObj) {
        const index = savedWrongQuestions.findIndex(q => q.question === questionObj.question);
        if (index !== -1) {
            savedWrongQuestions.splice(index, 1);
            saveWrongQuestionsToLocalStorage();
        }
    }
    let dataFileJson = [];
    let vocabularyData = {};
    let vocabularyLoaded = false;

    // Load vocabulary JSON and build dictionary
    async function loadVocabulary() {
        try {
            const data = await $.getJSON('../file/vocabulary/3000-english.json');
            if (Array.isArray(data)) {
                data.forEach(item => {
                    if (item.Word && item.Meaning) {
                        vocabularyData[item.Word.toLowerCase()] = item.Meaning;
                    }
                });
                vocabularyLoaded = true;
            } else {
                console.error('D·ªØ li·ªáu vocabulary kh√¥ng h·ª£p l·ªá:', data);
                vocabularyLoaded = false;
            }
        } catch (err) {
            console.error('Error loading vocabulary JSON:', err);
            vocabularyLoaded = false;
        }
    }

    // Function to wrap English words with Vietnamese meaning as small text above
    async function wrapWithMeaning(text) {
        if (!vocabularyLoaded) return text;

        if (!$("#showVocabulary").prop("checked")) {
            return text;
        }

        const isCategoryJapanese = $('input[name="categoryFilter"][value="Japanese"]').prop('checked');
        if (isCategoryJapanese) {
            // Use kuroshiro to convert Japanese text to furigana ruby markup
            await kuroshiroInitPromise; // wait for kuroshiro to be initialized

            const rubyMarkup = await kuroshiro.convert(text.trim(), { to: 'hiragana', mode: 'furigana' });
            return rubyMarkup;
        } else {
                    // Split text into words and non-words to preserve punctuation
            const parts = text.split(/(\W+)/);

            // Cache meanings to avoid repeated lookup
            const meaningCache = {};

            const wrappedParts = parts.map(part => {
                const lowerPart = part.toLowerCase();
                if (vocabularyData[lowerPart]) {
                    let meaningsArray;
                    if (meaningCache[lowerPart]) {
                        meaningsArray = meaningCache[lowerPart];
                    } else {
                        // Split meaning by ',' or ';' and trim
                        meaningsArray = vocabularyData[lowerPart].split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                        meaningCache[lowerPart] = meaningsArray;
                    }
                    // Pick a random meaning from the array
                    let randomMeaning = meaningsArray[Math.floor(Math.random() * meaningsArray.length)];
                    // Determine if the word is long to add class for letter spacing
                    let longWordClass = "";
                    if (part.length > 10) { // threshold for long word
                        longWordClass = "long-word";
                    }
                    // Wrap with ruby markup similar to hack1.html
                    return `<ruby><rb>${part}</rb><rt>${randomMeaning}</rt></ruby>`;
                } else {
                    return part;
                }
            });

            return wrappedParts.join('');
        }
    }

    // Timer functions for quiz countdown
    function startQuizTimer(duration) {
        timeRemaining = duration * 60; // convert minutes to seconds
        $("#timer").show();
        updateTimerDisplay();

        if (quizTimer) {
            clearInterval(quizTimer);
        }

        quizTimer = setInterval(() => {
            timeRemaining--;
            if (timeRemaining <= 0) {
                clearInterval(quizTimer);
                quizTimer = null;
                $("#timer").hide();
                alert("H·∫øt th·ªùi gian l√†m b√†i! B√†i l√†m s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông n·ªôp.");
                $("#submitQuiz").click();
            } else {
                updateTimerDisplay();
            }
        }, 1000);
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        $("#timeRemaining").text(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
    }

    $(function() {
        // Load vocabulary first, then load options and restore settings
        loadVocabulary().then(() => {
            loadOptions();
            restoreSettingsFromLocalStorage();
            setupDropdownEvents();

            // Initial call on page load
            updateShuffleAnswersOptionState();

            // Listen for changes on order radio buttons
            $(document).on("change", "input[name='order']", function() {
                updateShuffleAnswersOptionState();
            });
        });
    });

    // Disable or enable shuffleAnswersOption based on order selection
    function updateShuffleAnswersOptionState() {
        const orderValue = $("input[name='order']:checked").val();

        if (orderValue === "ordered") {
            $("input[name='shuffleAnswersOption']").prop("disabled", true);
            $("input[name='shuffleAnswersOption'][value='normal']").prop("checked", true)
        } else {
            $("input[name='shuffleAnswersOption']").prop("disabled", false);
        }
    }

    function updateQuizStatusBar() {
        const total = selectedQuestions.length;
        let done = 0;    // s·ªë c√¢u ƒë√£ ch·ªçn ƒë√°p √°n
        let correctCount = 0;
        let wrongCount = 0;

        for (let index = 0; index < total; index++) {
            const userAnswer = $(`input[name='q${index}']:checked`).val();
            if (userAnswer) {
                done++;
                if (userAnswer === getCorrectAnswer(selectedQuestions[index])) {
                    correctCount++;
                } else {
                    wrongCount++;
                }
            }
        }

        const start = parseInt($("#startQuestion").val()) || 1;
        const end = parseInt($("#endQuestion").val()) || questions.length;

        $("#quizStatusBar").text(`ƒê√£ l√†m (${start} ~ ${end}) ${done}/${total} c√¢u | ƒê√∫ng ${correctCount} | Sai ${wrongCount}`);

        if (total > 0) {
            $("#quizStatusBar").show();
        } else {
            $("#quizStatusBar").hide();
        }
    }

    function saveSettingsToLocalStorage() {
        const settings = {
            categoryNames: $("input[name='categoryFilter']:checked").map(function () { return this.value; }).get(),
            fileNames: $("input[name='jsonFiles']:checked").map(function () { return this.value; }).get(),
            startQuestion: $("#startQuestion").val(),
            endQuestion: $("#endQuestion").val(),
            randomQuestionCount: $("#randomQuestionCount").val(),
            order: $("input[name='order']:checked").val(),
            shuffleAnswersOption: $("input[name='shuffleAnswersOption']:checked").val()
        };
        try {
            localStorage.setItem('quizSettings', JSON.stringify(settings));
        } catch (e) {
            console.error('L·ªói khi l∆∞u c√†i ƒë·∫∑t quiz:', e);
        }
    }

    $(document).on("change input", "#startQuestion, #endQuestion, #randomQuestionCount, input[name='order'], input[name='shuffleAnswersOption'], input[name='categoryFilter']", saveSettingsToLocalStorage);

    function restoreSettingsFromLocalStorage() {
        const saved = localStorage.getItem('quizSettings');
        if (saved) {


            try {
                const settings = JSON.parse(saved);
                $("#startQuestion").val(settings.startQuestion);
                $("#endQuestion").val(settings.endQuestion);
                $("#randomQuestionCount").val(settings.randomQuestionCount);
                $(`input[name='order'][value='${settings.order}']`).prop("checked", true);
                if (settings.shuffleAnswersOption) {
                    $(`input[name='shuffleAnswersOption'][value='${settings.shuffleAnswersOption}']`).prop("checked", true);
                }

                // Sau khi checkbox load xong s·∫Ω set checked theo settings
                setTimeout(() => {
                    if (settings.categoryNames && settings.categoryNames.length > 0) {
                        $("input[name='categoryFilter']").each(function () {
                            this.checked = settings.categoryNames.includes(this.value);
                        });
                    }

                    renderFileCheckboxes();

                    $("input[name='jsonFiles']").each(function () {
                        if (settings.fileNames.includes(this.value)) {
                            this.checked = true;
                        }
                    });
                    updateDropdownButtonText();
                }, 500);

                // Call to update shuffleAnswersOption state after restoring settings
                updateShuffleAnswersOptionState();

            } catch (e) {
                console.error('L·ªói khi kh√¥i ph·ª•c c√†i ƒë·∫∑t quiz:', e);
            }
        }
    }

    let endQuenstionInit = 5;
    let isInit = true;
    $("#startQuiz").click(function () {
        const selectedFiles = $("input[name='jsonFiles']:checked").map(function () {
            return this.value;
        }).get();

        if (selectedFiles.length === 0) {
            showToast("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt file JSON!");
            return;
        }
        wrongQuestions = [];
        $("#retryWrong").hide();

        Promise.all(selectedFiles.map(f => $.getJSON(`../file/quiz/${f}`)))
            .then(fileDataList => {
                questions = fileDataList.flat();
                if (questions.length === 0) {
                    showToast("Kh√¥ng c√≥ c√¢u h·ªèi n√†o!");
                    return;
                }

                let start = parseInt($("#startQuestion").val()) || 1;
                let end = parseInt($("#endQuestion").val()) || questions.length;

                if (isInit) {
                    isInit = false;
                    endQuenstionInit = (end - start) + 1;
                }

                if (start === 0) {
                    start = 1;
                }

                if (start < 1 || end > questions.length || start > end) {
                    showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questions.length} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                    $('#continueQuiz').hide();
                    return;
                }

                selectedQuestions = questions.slice(start - 1, end);

                if ($("input[name='order']:checked").val() === "random") {
                    selectedQuestions = selectedQuestions.sort(() => Math.random() - 0.5);
                    const questionCount = Math.min(
                        parseInt($("#randomQuestionCount").val()) || selectedQuestions.length,
                        selectedQuestions.length
                    );
                    selectedQuestions = selectedQuestions.slice(0, questionCount);
                }

                renderQuiz();
                $("#quizContainer").show();
                $('.settings').hide();
                $('#startQuiz').hide();
                $('#retrySavedWrong').hide();
                startQuizTimer($('#quizDuration').val());

                const numberQuestion = (end - start) + 1;
                $("#continueQuiz").text(`L√†m ti·∫øp ${numberQuestion} c√¢u ti·∫øp`);
            })
            .catch(e => {
                console.error(e);
                showToast("L·ªói khi load file JSON!");
            });
    });

    async function renderQuiz() {
        const $quiz = $("#quiz");
        $quiz.empty();

        const tmpNo = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];

        for (let index = 0; index < selectedQuestions.length; index++) {
            const q = selectedQuestions[index];
            // B·ªè qua c√¢u h·ªèi n·∫øu thi·∫øu d·ªØ li·ªáu quan tr·ªçng
            if (!q.options || !q.correct_answer) {
                console.warn(`‚ö†Ô∏è B·ªè qua c√¢u h·ªèi ${index + 1}: thi·∫øu options ho·∫∑c correct_answer.`);
                continue;
            }

            let optionsArray = Object.entries(q.options).filter(item => item[1] !== '');

            // Determine shuffle mode
            const shuffleMode = $("input[name='shuffleAnswersOption']:checked").val();

            // Ki·ªÉm tra n·∫øu ƒë√°p √°n ƒë√∫ng l√† "All of the above"
            const isAllOfTheAbove = optionsArray.some(option => option[1] === "All of the above" && option[0] === q.correct_answer);

            if (shuffleMode === "normal" || isAllOfTheAbove) {
                optionsArray.sort(() => Math.random() - 0.5);
            } else if (shuffleMode === "basedOnCorrect") {
                // Collect all correct answers and their texts from other questions
                let otherCorrectOptions = [];

                selectedQuestions.forEach((item, idx) => {
                    if (idx !== index && item.correct_answer && item.options && item.options[item.correct_answer]) {
                        otherCorrectOptions.push({ key: tmpNo[otherCorrectOptions.length], value: item.options[item.correct_answer] });
                    }
                });

                // Add current question's correct answer
                const currentCorrectKey = q.correct_answer;
                const currentCorrectValue = q.options[currentCorrectKey];
                otherCorrectOptions = otherCorrectOptions.filter(option => option.key !== q.correct_answer);
                otherCorrectOptions.push({ key: currentCorrectKey, value: currentCorrectValue });
                
                // Remove duplicates by value
                const uniqueOptionsMap = {};
                otherCorrectOptions.forEach(opt => {
                    uniqueOptionsMap[opt.value] = opt;
                });
                let uniqueOptions = Object.values(uniqueOptionsMap);

                // Randomly select up to 4 options (or less if not enough)
                const maxOptions = Math.min(4, uniqueOptions.length);
                const selectedOptions = [];

                while (selectedOptions.length < maxOptions) {
                    const randIndex = Math.floor(Math.random() * uniqueOptions.length);
                    const option = uniqueOptions.splice(randIndex, 1)[0];
                    if (option.key == currentCorrectKey) {
                        option.key = tmpNo[selectedOptions.length];
                        q.correct_answer_actual = option.key
                    } else {
                        option.key = tmpNo[selectedOptions.length];
                    }
                    
                    selectedOptions.push(option);
                }

                // Ensure current correct answer is included
                if (!selectedOptions.some(opt => opt.key === currentCorrectKey)) {
                    selectedOptions.pop();
                    selectedOptions.push({ key: currentCorrectKey, value: currentCorrectValue });
                }

                // Shuffle final options
                selectedOptions.sort(() => Math.random() - 0.5);

                optionsArray = selectedOptions.map(opt => [opt.key, opt.value]);
            }

            let idxNo = -1;
            let optionsHtml = "";

            for (let i = 0; i < optionsArray.length; i++) {
                const key = optionsArray[i][0];
                const value = optionsArray[i][1];

                idxNo++;
                const isLast = (idxNo === optionsArray.length - 1);

                const wrappedMeaning = await wrapWithMeaning(value);

                optionsHtml += `
                    <div data-index="${index}" style="display: flex; align-items: center; justify-content: space-between;">
                        <label style="flex: 1;">
                            <input type="radio" name="q${index}" value="${key}">
                            ${tmpNo[idxNo]}. ${wrappedMeaning}
                        </label>
                        ${isLast ? `
                            <button class="btn check-answer" data-index="${index}" style="padding: 6px 12px; font-size: 14px;">Ki·ªÉm tra</button>
                            <span class="tooltip-wrapper" style="position: relative; display: inline-block;">
                                <span class="explain-tooltip-icon disabled-tooltip" title="Xem gi·∫£i th√≠ch" data-index="${index}"
                                    style="display:none; cursor:pointer; font-size: 18px; color: #007bff;">üí°</span>
                                <div class="explain-tooltip-content">
                                    ${q.explanation || "Ch∆∞a c√≥ gi·∫£i th√≠ch."}
                                </div>
                            </span>
                        ` : ''}
                    </div>
                `;
            }

            // Check if there is an image to display
            const imageHtml = q.image ? `<img src="${q.image}" alt="Question Image" style="max-width: 100%; height: auto; margin-top: 10px;">` : '';

            let correctCountDisplay = "";
            const savedWrongEntry = savedWrongQuestions.find(entry => entry.question === q.question);
            if (savedWrongEntry) {
                correctCountDisplay = `<span id="spnCorrectCount" title="L·∫ßn ƒë√∫ng li√™n ti·∫øp" style="display: inline-block; background-color: green; color: white; border-radius: 50%; width: 20px; height: 20px; line-height: 20px; text-align: center; font-weight: bold; margin-left: 10px; font-size: 12px;">${savedWrongEntry.correctCount}</span>`;
            }
            const wrappedQuestion = await wrapWithMeaning(q.question);
            $quiz.append(`
                <div class="question" style="position: relative;">
                    ${index + 1}. ${wrappedQuestion} ${correctCountDisplay}
                    <span class="translate-icon" data-index="${index}" title="D·ªãch c√¢u h·ªèi" 
                        style="cursor:pointer; margin-left:10px; font-size:18px; color:#007bff;">üîÑ</span>
                    <span class="chatgpt-icon" data-index="${index}" title="H·ªèi ChatGPT"
                        style="cursor:pointer; margin-left:10px; font-size:18px; color:#28a745;">ü§ñ</span>
                    <div class="translation" style="color: #555; margin-top: 5px; display:none;"></div>
                    ${imageHtml}
                </div>
                <div class="options">${optionsHtml}</div>
                <hr>
            `);
        }
        updateQuizStatusBar();
    }

    // B·∫Øt s·ª± ki·ªán click icon ChatGPT - copy prompt + m·ªü tab ChatGPT
    $(document).on('click', '.chatgpt-icon', function () {
        const $this = $(this);
        const index = $this.data('index');
        const questionObj = selectedQuestions[index];

        let fullText = `1. D·ªãch v·ª´a c√≥ ti·∫øng anh v√† ti·∫øng vi·ªát\n`;
        fullText += `2. Tr√≠ch d·∫´n t·ª´ BABOK V3 ·ªü c√¢u ƒë√∫ng\n`;
        fullText += `C√¢u h·ªèi: ${questionObj.question}\n`;

        for (const key in questionObj.options) {
            fullText += `${key}. ${questionObj.options[key]}\n`;
        }

        fullText += `\nƒê√°p √°n c·ªßa t√¥i l√†: ${questionObj.correct_answer}`;

        // Copy v√†o clipboard
        navigator.clipboard.writeText(fullText)
            .then(() => {
                window.open("https://chatgpt.com/?temporary-chat=true", '_blank');
            })
            .catch(err => {
                showToast("Kh√¥ng th·ªÉ copy v√†o clipboard. Vui l√≤ng th·ª≠ l·∫°i.");
                console.error(err);
            });
    });

    // B·∫Øt s·ª± ki·ªán click icon d·ªãch
    $(document).on('click', '.translate-icon', function () {
        const $this = $(this);
        const index = $this.data('index');
        const questionObj = selectedQuestions[index];

        // N·ªëi c√¢u h·ªèi + t·ª´ng ƒë√°p √°n th√†nh 1 chu·ªói
        let fullText = questionObj.question + '\n';
        for (const key in questionObj.options) {
            fullText += `${key}. ${questionObj.options[key]}\n`;
        }

        // M√£ h√≥a v√† m·ªü tab m·ªõi Google Translate
        const url = `https://translate.google.com/?sl=en&tl=vi&text=${encodeURIComponent(fullText)}&op=translate`;
        window.open(url, '_blank');
    });

    function getCorrectAnswer(selectedQuestion) {
        let correctAnswer = selectedQuestion.correct_answer;
        if (selectedQuestion.correct_answer_actual !== undefined) {
            correctAnswer = selectedQuestion.correct_answer_actual;
        }
        return correctAnswer;
    }

    $(document).on("click", ".check-answer", function () {
        const $this = $(this);
        const index = $this.data("index");
        const selected = $(`input[name='q${index}']:checked`).val();
        const correct = getCorrectAnswer(selectedQuestions[index]);

        if (!selected) {
            showToast("Vui l√≤ng ch·ªçn m·ªôt ƒë√°p √°n tr∆∞·ªõc khi ki·ªÉm tra!");
            return;
        }

        $(`input[name='q${index}']`).prop("disabled", true);

        $(`input[name='q${index}'][value='${correct}']`).parent().addClass("correct");
        const questionObj = selectedQuestions[index];
        let savedWrongEntry = savedWrongQuestions.find((q, idx) => {
            if (q.question === questionObj.question &&
                q.correct_answer === questionObj.correct_answer &&
                compareOptions(q.options, questionObj.options)) {
                return q;
            }
        });

        if (selected !== correct) {
            $(`input[name='q${index}'][value='${selected}']`).parent().addClass("incorrect");
            // ‚ûï Th√™m c√¢u sai v√†o danh s√°ch n·∫øu ch∆∞a c√≥
            if (!wrongQuestions.includes(questionObj)) {
                wrongQuestions.push(questionObj);
            }
            // Th√™m c√¢u sai v√†o savedWrongQuestions ho·∫∑c reset correctCount n·∫øu ƒë√£ c√≥
            if (savedWrongEntry) {
                savedWrongEntry.correctCount = 0;
            } else {
                addToSavedWrongQuestions(questionObj);
            }
        } else {
            // N·∫øu tr·∫£ l·ªùi ƒë√∫ng, tƒÉng correctCount n·∫øu c√≥ trong savedWrongQuestions
            if (savedWrongEntry) {
                savedWrongEntry.correctCount++;
                $this.parent().parent().prev().find('#spnCorrectCount').text(`${savedWrongEntry.correctCount}`);
                if (savedWrongEntry.correctCount >= 3) {
                    // X√≥a c√¢u ƒë√∫ng kh·ªèi savedWrongQuestions n·∫øu ƒë·∫°t 3 l·∫ßn ƒë√∫ng li√™n ti·∫øp
                    removeFromSavedWrongQuestions(questionObj);
                    if (wrongQuestions.includes(questionObj)) {
                        const indexRemove = wrongQuestions.indexOf(questionObj);
                        wrongQuestions.splice(indexRemove, 1);
                    }

                    if (savedWrongQuestions.length == 0) {
                        $('#resetting').click();
                    }
                }
            }
            if (wrongQuestions.includes(questionObj)) {
                const indexRemove = wrongQuestions.indexOf(questionObj);
                wrongQuestions.splice(indexRemove, 1);
            }
        }

        saveWrongQuestionsToLocalStorage();
        updateQuizStatusBar();
        if (wrongQuestions.length > 0) {
            $("#retryWrong").show(); // Hi·ªán n√∫t "L√†m l·∫°i c√¢u sai"
        } else {
            $("#retryWrong").hide();
        }

        $(`.explain-tooltip-icon[data-index='${index}']`).show();

        $this.hide();
    });

    $("#submitQuiz").click(function () {
        let score = 0;
        wrongQuestions = []; // Reset

        selectedQuestions.forEach((q, index) => {
            const userAnswer = $(`input[name='q${index}']:checked`).val();
            let correctAnswer = getCorrectAnswer(q);

            if (userAnswer === correctAnswer) {
                score++;
                $(`input[name='q${index}'][value='${correctAnswer}']`).parent().addClass("correct");
                // X√≥a c√¢u ƒë√∫ng kh·ªèi savedWrongQuestions n·∫øu c√≥
                removeFromSavedWrongQuestions(q);
            } else {
                $(`input[name='q${index}'][value='${correctAnswer}']`).parent().addClass("correct");
                if (userAnswer) {
                    $(`input[name='q${index}'][value='${userAnswer}']`).parent().addClass("incorrect");
                }
                wrongQuestions.push(q);
                // Th√™m c√¢u sai v√†o savedWrongQuestions
                addToSavedWrongQuestions(q);
            }
            $(`input[name='q${index}']`).prop("disabled", true);
        });

        updateQuizStatusBar();

        if (wrongQuestions.length > 0) {
            $("#retryWrong").show(); // Hi·ªán n√∫t "L√†m l·∫°i c√¢u sai"
        } else {
            showToast("B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng t·∫•t c·∫£ c√°c c√¢u h·ªèi üéâ");
        }
    });

    $("#resetting").click(function () {
        window.scrollTo(0, 0);
        $('.settings').show();
        $('#startQuiz').show();
        $('#quizContainer').hide();
        if (savedWrongQuestions.length > 0) {
            $('#retrySavedWrong').show();
        } else {
            $('#retrySavedWrong').hide();
        }
    });

    function loadOptions() {
        const listFileName = `../file/quiz/data-file-name.json`;
        $.getJSON(listFileName)
            .done(data => {
                const $categoryContainer = $('#categoryRadio');
                const $container = $('#fileListCheckboxes');
                $container.html('<label><input type="checkbox" id="checkAllFiles"><em>Ch·ªçn t·∫•t c·∫£</em></label>');
                allFileNames = data.map(u => u.value);
                dataFileJson = data;

                // Extract unique categories
                const categories = [...new Set(data.map(item => item.category))];

                // Render category checkboxes
                $categoryContainer.empty();
                categories.forEach(cat => {
                    const $catRadio = $('<input>', {
                        type: 'radio',
                        name: 'categoryFilter',
                        value: cat,
                        id: `cat_${cat.replace(/\s+/g, '_')}`
                    });

                    const $catLabel = $('<label>', {
                        for: $catRadio.attr('id'),
                        style: 'margin-right: 10px;'
                    }).append($catRadio).append(` ${cat}`);

                    $categoryContainer.append($catLabel);
                });

                // Initial render of file checkboxes
                renderFileCheckboxes();

                // Add event listeners for category radios to filter files
                $(document).off('change', "input[name='categoryFilter']");
                $(document).on('change', "input[name='categoryFilter']", () => {
                    renderFileCheckboxes();
                });
            })
            .fail(err => {
                showToast("L·ªói khi t·∫£i file JSON: " + err.statusText);
            });
    }


    // Function to render file checkboxes filtered by selected category
    function renderFileCheckboxes() {
        const $selectedCategory = $("input[name='categoryFilter']:checked");
        const $container = $('#fileListCheckboxes');
        $container.html('<label><input type="checkbox" id="checkAllFiles"><em>Ch·ªçn t·∫•t c·∫£</em></label>');

        let filteredData = [];
        if ($selectedCategory.length > 0) {
            filteredData = dataFileJson.filter(item => item.category === $selectedCategory.val());
        }

        filteredData.forEach(item => {
            const $checkbox = $('<input>', {
                type: 'checkbox',
                name: 'jsonFiles',
                value: item.value,
                id: `chk_${item.value}`
            });

            const $label = $('<label>', {
                for: $checkbox.attr('id')
            }).append($checkbox).append(` ${item.key}`);

            $container.append($label);
        });

        // Add event listeners for file checkboxes
        $('#checkAllFiles').off('change').on('change', function () {
            const checked = this.checked;
            $("input[name='jsonFiles']").prop('checked', checked);
            updateDropdownButtonText();
            saveSettingsToLocalStorage();
        });

        $container.find("input[name='jsonFiles']").off('change').on('change', function () {
            updateCheckAllState();
            updateDropdownButtonText();
            saveSettingsToLocalStorage();
        });

        updateCheckAllState();
        updateDropdownButtonText();
    }

    $("#retryWrong").click(function () {
        if (wrongQuestions.length === 0) {
            showToast("Kh√¥ng c√≥ c√¢u sai ƒë·ªÉ l√†m l·∫°i.");
            return;
        }

        selectedQuestions = [...wrongQuestions]; // D√πng l·∫°i danh s√°ch sai
        renderQuiz();
        updateQuizStatusBar();
        $(this).hide(); // ·∫®n n√∫t sau khi d√πng
    });

    // X·ª≠ l√Ω n√∫t l√†m l·∫°i c√¢u sai ƒë√£ l∆∞u
    let isRetrySavedWrongMode = false;

    $("#retrySavedWrong").click(function () {
        if (savedWrongQuestions.length === 0) {
            showToast("Kh√¥ng c√≥ c√¢u sai ƒë√£ l∆∞u ƒë·ªÉ l√†m l·∫°i.");
            return;
        }
        
        isRetrySavedWrongMode = true;

        let start = parseInt($("#startQuestion").val()) || 1;
        let end = parseInt($("#endQuestion").val()) || questions.length;

        $("#quizContainer").show();
        $('.settings').hide();
        $('#startQuiz').hide();
        let numberQuestion = (end - start) + 1;
        $("#continueQuiz").text(`L√†m ti·∫øp ${numberQuestion} c√¢u ti·∫øp`);

        selectedQuestions = [...savedWrongQuestions];
        renderQuiz();
        updateQuizStatusBar();
        $(this).hide(); // ·∫®n n√∫t sau khi d√πng
    });

    $("#retest").click(function () {
        if (isRetrySavedWrongMode) {
            // Retest retrySavedWrong questions
            selectedQuestions = [...savedWrongQuestions];
        } else {
            // Retest current selected questions
            selectedQuestions = selectedQuestions.slice();
        }
        renderQuiz();
        updateQuizStatusBar();
        $(this).blur(); // Remove focus after click for better UX
    });

    $("#resetting").click(function () {
        isRetrySavedWrongMode = false;
        window.scrollTo(0, 0);
        $('.settings').show();
        $('#startQuiz').show();
        $('#quizContainer').hide();
        if (savedWrongQuestions.length > 0) {
            $('#retrySavedWrong').show();
        } else {
            $('#retrySavedWrong').hide();
        }
    });

    // Hi·ªÉn th·ªã n√∫t l√†m l·∫°i c√¢u sai ƒë√£ l∆∞u n·∫øu c√≥ d·ªØ li·ªáu
    function updateRetrySavedWrongButton() {
        const $btn = $("#retrySavedWrong");
        if (savedWrongQuestions.length > 0) {
            $btn.show();
        } else {
            $btn.hide();
        }
    }

    // G·ªçi h√†m update n√∫t khi load trang v√† sau m·ªói l·∫ßn l∆∞u/x√≥a c√¢u sai
    $(document).ready(function () {
        loadSavedWrongQuestions();
        updateRetrySavedWrongButton();
    });

    function updateCheckAllState() {
        const $allCheckboxes = $("input[name='jsonFiles']");
        const $checkedBoxes = $("input[name='jsonFiles']:checked");
        const $checkAll = $("#checkAllFiles");
        if ($checkedBoxes.length === $allCheckboxes.length) {
            $checkAll.prop("checked", true);
            $checkAll.prop("indeterminate", false);
        } else if ($checkedBoxes.length > 0) {
            $checkAll.prop("checked", false);
            $checkAll.prop("indeterminate", true);
        } else {
            $checkAll.prop("checked", false);
            $checkAll.prop("indeterminate", false);
        }
    }

    function updateDropdownButtonText() {
        const $checkedBoxes = $("input[name='jsonFiles']:checked");
        const $button = $("#dropdownButton");
        if ($checkedBoxes.length === 0) {
            $button.text('Ch·ªçn file JSON');
        } else if ($checkedBoxes.length === 1) {
            $button.text($checkedBoxes.first().parent().text().trim());
        } else {
            $button.text(`ƒê√£ ch·ªçn ${$checkedBoxes.length} file`);
        }
    }

    function setupDropdownEvents() {
        const $dropdownButton = $('#dropdownButton');
        const $dropdownContent = $('#dropdownContent');

        $dropdownButton.off('click').on('click', function (e) {
            e.stopPropagation();
            if ($dropdownContent.is(':visible')) {
                $dropdownContent.hide();
                $dropdownButton.attr('aria-expanded', 'false');
            } else {
                $dropdownContent.show();
                $dropdownButton.attr('aria-expanded', 'true');
            }
        });

        // ƒê√≥ng dropdown n·∫øu click ngo√†i
        $(document).off('click.dropdown').on('click.dropdown', function () {
            $dropdownContent.hide();
            $dropdownButton.attr('aria-expanded', 'false');
        });

        // NgƒÉn kh√¥ng cho dropdown ƒë√≥ng khi click trong n·ªôi dung
        $dropdownContent.off('click').on('click', function (e) {
            e.stopPropagation();
        });
    }
    function showToast(message, duration = 3000) {
        const $toast = $("#toast");
        $toast.text(message).addClass("show").show();

        setTimeout(() => {
            $toast.removeClass("show").hide();
        }, duration);
    }
    (function() {
        let tooltipTimeout;
        $(document).on("mouseenter", ".explain-tooltip-icon", function () {
            const $this = $(this);
            if (!$this.hasClass("disabled-tooltip")) {
                clearTimeout(tooltipTimeout);
                $this.siblings(".explain-tooltip-content").stop(true, true).fadeIn(200);
            }
        }).on("mouseleave", ".explain-tooltip-icon", function () {
            const $this = $(this);
            tooltipTimeout = setTimeout(() => {
                $this.siblings(".explain-tooltip-content").stop(true, true).fadeOut(200);
            }, 300);
        });
    })();

    // Dark mode toggle logic
    const darkModeToggle = $('#darkModeToggle');
    const body = $('body');

    // Load saved preference
    if (localStorage.getItem('darkMode') === 'enabled') {
        body.addClass('dark-mode');
    }

    darkModeToggle.off('click').on('click', function () {
        body.toggleClass('dark-mode');
        if (body.hasClass('dark-mode')) {
            localStorage.setItem('darkMode', 'enabled');
        } else {
            localStorage.setItem('darkMode', 'disabled');
        }
    });

    // New button "L√†m ti·∫øp" click handler
    $("#continueQuiz").click(function () {
        const $startQuestion = $("#startQuestion");
        const $endQuestion = $("#endQuestion");
        const $continueQuiz = $("#continueQuiz");
        const questionsLength = questions.length;

        let start = parseInt($startQuestion.val()) || 1;
        let end = parseInt($endQuestion.val()) || questionsLength;

        const beforeEnd = end;

        start += endQuenstionInit;
        end += endQuenstionInit;

        if (end > questionsLength) {
            if (beforeEnd === questionsLength && end > questionsLength) {
                showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questionsLength} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                $continueQuiz.hide();
                return;
            }
            start = beforeEnd + 1;
            end = questionsLength;
        } else {
            if (start < 1 || end > questionsLength || start > end) {
                showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questionsLength} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                $continueQuiz.hide();
                return;
            }
        }

        $startQuestion.val(start);
        $endQuestion.val(end);
        $continueQuiz.text(`L√†m ti·∫øp ${endQuenstionInit} c√¢u ti·∫øp`);

        $("#startQuiz").click();
    });
    
</script>
<style>
    ruby {
      ruby-position: over;
    }

    ruby rb {
      font-size: 16px; /* l√†m nh·ªè Kanji */
      color: #28a745;
    }

    ruby rt {
      font-size: 8px; /* ho·∫∑c c√πng k√≠ch th∆∞·ªõc v·ªõi rb */
      color: #555;
      padding: 0px 0px 1px 0px;
    }
    
    #timer {
        position: fixed;
        top: 50px; /* Adjust as needed to avoid overlap with other elements */
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        z-index: 4000;
        font-weight: bold;
        font-size: 18px;
        margin-top: 0;
        display: none; /* Keep initial hidden, JS will show it */
    }

    body:not(.dark-mode) #timer {
        background-color: rgba(255, 255, 255, 0.9);
        color: black;
    }
</style>
</body>
</html>
