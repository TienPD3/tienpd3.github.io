<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Quiz Tr·∫Øc Nghi·ªám - Udemy Style</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script defer src="/website/scripts/kuroshiro/kuroshiro.min.js"></script>
    <script defer src="/website/scripts/kuroshiro/kuroshiro-analyzer-kuromoji.min.js"></script>
    <link rel="stylesheet" href="../css/web/quiz.css" />
</head>
<body>

<button id="darkModeToggle" style="position: fixed; top: 10px; left: 10px; z-index: 3000; padding: 8px 12px; border-radius: 5px; border: none; background-color: #007bff; color: white; cursor: pointer;">Toggle Dark Mode</button>

<div id="quizStatusBar">
    ƒê√£ l√†m 0/0 c√¢u | ƒê√∫ng 0 | Sai 0
</div>

<div class="container">
    <h2>Tr·∫Øc Nghi·ªám Business Analysis</h2>

    <!-- C√†i ƒë·∫∑t Quiz -->
    <div class="settings">
        <div id="categoryRadio" style="margin-bottom: 10px;">
            <!-- Radio categories s·∫Ω load ·ªü ƒë√¢y -->
        </div>
        <div class="dropdown-checkbox" id="dropdownCheckboxWrapper">
            <button type="button" id="dropdownButton" aria-haspopup="true" aria-expanded="false">Ch·ªçn file JSON</button>
            <div class="dropdown-content" id="dropdownContent">
                <div id="fileListCheckboxes">
                    <!-- Checkbox files s·∫Ω load ·ªü ƒë√¢y -->
                </div>
            </div>
        </div>

        <br />

        <label><input type="checkbox" id="showVocabulary" checked> Hi·ªÉn th·ªã Vocabulary</label>
        <br />

        <label>Th·ªùi gian l√†m b√†i (ph√∫t):</label>
        <input type="number" id="quizDuration" value="15" min="1" style="width: 50px;">
        <br>

        <label>T·ª´ c√¢u:</label>
        <input type="number" id="startQuestion" value="0" step="5" min="0" style="width: 50px;">

        <label>ƒê·∫øn c√¢u:</label>
        <input type="number" id="endQuestion" value="" step="5" min="5" style="width: 50px;">
        <br>

        <label>S·ªë c√¢u h·ªèi ng·∫´u nhi√™n:</label>
        <input type="number" id="randomQuestionCount" value="5" step="5" min="0" style="width: 50px;">
        <br>

        <label><input type="radio" name="order" value="ordered" checked> Theo th·ª© t·ª±</label>
        <label><input type="radio" name="order" value="random"> Ng·∫´u nhi√™n</label>
        <br>

        <label><input type="radio" name="shuffleAnswersOption" value="normal" checked> Ng·∫´u nhi√™n d·ªÖ</label>
        <label><input type="radio" name="shuffleAnswersOption" value="basedOnCorrect"> Ng·∫´u nhi√™n kh√≥</label>
    </div>

    <button class="btn" id="startQuiz">B·∫Øt ƒë·∫ßu</button>
    <button class="btn" id="retrySavedWrong">L√†m l·∫°i c√¢u sai ƒë√£ l∆∞u</button>
    <div id="timer" style="font-weight: bold; font-size: 18px; margin-top: 10px; display: none;">Th·ªùi gian c√≤n l·∫°i: <span id="timeRemaining">00:00</span></div>
    <div id="quizContainer" style="display: none;">
        <div id="quiz"></div>
        <div class="leftButtonGroup">
            <button class="btn" id="resetting">C√†i ƒë·∫∑t</button>
            <button class="btn" id="retest">L√†m l·∫°i</button>
        </div>
        <div class="rightButtonGroup">
            <button class="btn hidden" id="retryWrong">L√†m l·∫°i c√¢u sai</button>
            <button class="btn" id="submitQuiz">N·ªôp b√†i</button>
            <button class="btn" id="continueQuiz">L√†m ti·∫øp</button>
        </div>
    </div>
</div>
<div id="toast" style="display: none;"></div>

<script>
    // =========================================================================
    // 1. Global Variables & Initialization
    // =========================================================================
    let questions = [];
    let selectedQuestions = [];
    let allFileNames = [];
    let wrongQuestions = [];
    let savedWrongQuestions = [];
    let quizTimer = null;
    let timeRemaining = 0;
    let dataFileJson = [];
    let vocabularyData = {};
    let vocabularyLoaded = false;
    let kuroshiro;
    let kuroshiroInitPromise;
    let endQuenstionInit = 5;
    let isInit = true;
    let isRetrySavedWrongMode = false;

    $(document).ready(function() {
        // Initialize Kuroshiro for Japanese text processing
        kuroshiro = new Kuroshiro();
        kuroshiroInitPromise = kuroshiro.init(new KuromojiAnalyzer());

        // Load vocabulary and quiz settings on document ready
        loadVocabulary().then(() => {
            loadOptions();
            restoreSettingsFromLocalStorage();
            setupDropdownEvents();
            updateShuffleAnswersOptionState(); // Initial state update
            updateRetrySavedWrongButton(); // Initial button state
        });

        // Event listeners for settings changes
        $(document).on("change input", "#startQuestion, #endQuestion, #randomQuestionCount, #quizDuration, input[name='order'], input[name='shuffleAnswersOption'], input[name='categoryFilter'], #showVocabulary", saveSettingsToLocalStorage);
        $(document).on("change", "input[name='order']", updateShuffleAnswersOptionState);
    });

    // =========================================================================
    // 2. Local Storage Management
    // =========================================================================

    /**
     * Loads saved wrong questions from localStorage, handling chunking.
     */
    function loadSavedWrongQuestions() {
        savedWrongQuestions = [];
        for (let index = 0; ; index++) {
            const key = `savedWrongQuestions_${index}`;
            let chunk = null;
            try {
                chunk = localStorage.getItem(key);
                if (!chunk) break;
                const parsed = JSON.parse(chunk);
                if (Array.isArray(parsed)) {
                    parsed.forEach(q => {
                        if (typeof q.correctCount !== 'number') {
                            q.correctCount = 0;
                        }
                    });
                    savedWrongQuestions.push(...parsed);
                }
            } catch (e) {
                console.error(`L·ªói khi ph√¢n t√≠ch ${key}:`, e);
                break;
            }
        }
    }

    /**
     * Saves wrong questions to localStorage, handling chunking and quota.
     */
    function saveWrongQuestionsToLocalStorage() {
        for (let index = 0; ; index++) {
            const key = `savedWrongQuestions_${index}`;
            if (localStorage.getItem(key) === null) break;
            localStorage.removeItem(key);
        }

        let chunkSize = 50;
        let start = 0;
        while (start < savedWrongQuestions.length) {
            let end = Math.min(start + chunkSize, savedWrongQuestions.length);
            let chunk = savedWrongQuestions.slice(start, end);
            let key = `savedWrongQuestions_${Math.floor(start / chunkSize)}`;
            try {
                localStorage.setItem(key, JSON.stringify(chunk));
                start = end;
            } catch (e) {
                if (chunkSize === 1) {
                    console.error('L·ªói khi l∆∞u savedWrongQuestions, d·ªØ li·ªáu qu√° l·ªõn ƒë·ªÉ l∆∞u:', e);
                    break;
                }
                chunkSize = Math.floor(chunkSize / 2);
                if (chunkSize < 1) chunkSize = 1;
            }
        }
    }

    /**
     * Saves current quiz settings to localStorage.
     */
    function saveSettingsToLocalStorage() {
        const settings = {
            categoryNames: $("input[name='categoryFilter']:checked").map(function () { return this.value; }).get(),
            fileNames: $("input[name='jsonFiles']:checked").map(function () { return this.value; }).get(),
            startQuestion: $("#startQuestion").val(),
            endQuestion: $("#endQuestion").val(),
            randomQuestionCount: $("#randomQuestionCount").val(),
            quizDuration: $("#quizDuration").val(),
            order: $("input[name='order']:checked").val(),
            shuffleAnswersOption: $("input[name='shuffleAnswersOption']:checked").val(),
            showVocabulary: $("#showVocabulary").prop("checked")
        };
        try {
            localStorage.setItem('quizSettings', JSON.stringify(settings));
        } catch (e) {
            console.error('L·ªói khi l∆∞u c√†i ƒë·∫∑t quiz:', e);
        }
    }

    /**
     * Restores quiz settings from localStorage.
     */
    function restoreSettingsFromLocalStorage() {
        const saved = localStorage.getItem('quizSettings');
        if (saved) {
            try {
                const settings = JSON.parse(saved);
                $("#startQuestion").val(settings.startQuestion);
                $("#endQuestion").val(settings.endQuestion);
                $("#randomQuestionCount").val(settings.randomQuestionCount);
                if (settings.quizDuration !== undefined) {
                    $("#quizDuration").val(settings.quizDuration);
                }
                $(`input[name='order'][value='${settings.order}']`).prop("checked", true);
                if (settings.shuffleAnswersOption) {
                    $(`input[name='shuffleAnswersOption'][value='${settings.shuffleAnswersOption}']`).prop("checked", true);
                }
                if (typeof settings.showVocabulary === "boolean") {
                    $("#showVocabulary").prop("checked", settings.showVocabulary);
                }

                setTimeout(() => {
                    if (settings.categoryNames && settings.categoryNames.length > 0) {
                        $("input[name='categoryFilter']").each(function () {
                            this.checked = settings.categoryNames.includes(this.value);
                        });
                    }
                    renderFileCheckboxes();
                    $("input[name='jsonFiles']").each(function () {
                        if (settings.fileNames.includes(this.value)) {
                            this.checked = true;
                        }
                    });
                    updateDropdownButtonText();
                }, 500);
                updateShuffleAnswersOptionState();
            } catch (e) {
                console.error('L·ªói khi kh√¥i ph·ª•c c√†i ƒë·∫∑t quiz:', e);
            }
        }
    }

    // =========================================================================
    // 3. Vocabulary & Text Processing
    // =========================================================================

    /**
     * Loads vocabulary JSON and builds a dictionary.
     */
    async function loadVocabulary() {
        try {
            const data = await $.getJSON('../file/vocabulary/3000-english.json');
            if (Array.isArray(data)) {
                data.forEach(item => {
                    if (item.Word && item.Meaning) {
                        vocabularyData[item.Word.toLowerCase()] = item.Meaning;
                    }
                });
                vocabularyLoaded = true;
            } else {
                console.error('D·ªØ li·ªáu vocabulary kh√¥ng h·ª£p l·ªá:', data);
                vocabularyLoaded = false;
            }
        } catch (err) {
            console.error('Error loading vocabulary JSON:', err);
            vocabularyLoaded = false;
        }
    }

    /**
     * Wraps English words with Vietnamese meaning or converts Japanese text to furigana.
     * @param {string} text - The text to process.
     * @returns {Promise<string>} The processed HTML string.
     */
    async function wrapWithMeaning(text) {
        if (!vocabularyLoaded) return text;
        if (!$("#showVocabulary").prop("checked")) return text;

        const isCategoryJapanese = $('input[name="categoryFilter"][value="Japanese"]').prop('checked');
        if (isCategoryJapanese) {
            await kuroshiroInitPromise;
            return await kuroshiro.convert(text.trim(), { to: 'hiragana', mode: 'furigana' });
        } else {
            const parts = text.split(/(\W+)/);
            const meaningCache = {};
            const wrappedParts = parts.map(part => {
                const lowerPart = part.toLowerCase();
                if (vocabularyData[lowerPart]) {
                    let meaningsArray;
                    if (meaningCache[lowerPart]) {
                        meaningsArray = meaningCache[lowerPart];
                    } else {
                        meaningsArray = vocabularyData[lowerPart].split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                        meaningCache[lowerPart] = meaningsArray;
                    }
                    let randomMeaning = meaningsArray[Math.floor(Math.random() * meaningsArray.length)];
                    return `<ruby><rb>${part}</rb><rt>${randomMeaning}</rt></ruby>`;
                } else {
                    return part;
                }
            });
            return wrappedParts.join('');
        }
    }

    // =========================================================================
    // 4. Quiz Logic & Rendering
    // =========================================================================

    /**
     * Starts the quiz countdown timer.
     * @param {number} duration - The quiz duration in minutes.
     */
    function startQuizTimer(duration) {
        timeRemaining = duration * 60;
        $("#timer").show();
        updateTimerDisplay();

        if (quizTimer) {
            clearInterval(quizTimer);
        }

        quizTimer = setInterval(() => {
            timeRemaining--;
            if (timeRemaining <= 0) {
                clearInterval(quizTimer);
                quizTimer = null;
                $("#timer").hide();
                alert("H·∫øt th·ªùi gian l√†m b√†i! B√†i l√†m s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông n·ªôp.");
                $("#submitQuiz").click();
            } else {
                updateTimerDisplay();
            }
        }, 1000);
    }

    /**
     * Updates the timer display.
     */
    function updateTimerDisplay() {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        $("#timeRemaining").text(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
    }

    /**
     * Updates the quiz status bar with current progress.
     */
    function updateQuizStatusBar() {
        const total = selectedQuestions.length;
        let done = 0;
        let correctCount = 0;
        let wrongCount = 0;

        for (let index = 0; index < total; index++) {
            const userAnswer = $(`input[name='q${index}']:checked`).val();
            if (userAnswer) {
                done++;
                if (userAnswer === getCorrectAnswer(selectedQuestions[index])) {
                    correctCount++;
                } else {
                    wrongCount++;
                }
            }
        }

        const start = parseInt($("#startQuestion").val()) || 1;
        const end = parseInt($("#endQuestion").val()) || questions.length;

        $("#quizStatusBar").text(`ƒê√£ l√†m (${start} ~ ${end}) ${done}/${total} c√¢u | ƒê√∫ng ${correctCount} | Sai ${wrongCount}`);

        if (total > 0) {
            $("#quizStatusBar").show();
        } else {
            $("#quizStatusBar").hide();
        }
    }

    /**
     * Renders the quiz questions and options.
     */
    async function renderQuiz() {
        const $quiz = $("#quiz");
        $quiz.empty();
        const tmpNo = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];

        for (let index = 0; index < selectedQuestions.length; index++) {
            const q = selectedQuestions[index];
            if (!q.options || !q.correct_answer) {
                console.warn(`‚ö†Ô∏è B·ªè qua c√¢u h·ªèi ${index + 1}: thi·∫øu options ho·∫∑c correct_answer.`);
                continue;
            }

            let optionsArray = Object.entries(q.options).filter(item => item[1] !== '');
            const shuffleMode = $("input[name='shuffleAnswersOption']:checked").val();
            const isAllOfTheAbove = optionsArray.some(option => option[1] === "All of the above" && option[0] === q.correct_answer);

            if (shuffleMode === "normal" || isAllOfTheAbove) {
                optionsArray.sort(() => Math.random() - 0.5);
            } else if (shuffleMode === "basedOnCorrect") {
                let otherCorrectOptions = [];
                selectedQuestions.forEach((item, idx) => {
                    if (idx !== index && item.correct_answer && item.options && item.options[item.correct_answer]) {
                        otherCorrectOptions.push({ key: tmpNo[otherCorrectOptions.length], value: item.options[item.correct_answer] });
                    }
                });

                const currentCorrectKey = q.correct_answer;
                const currentCorrectValue = q.options[currentCorrectKey];
                otherCorrectOptions = otherCorrectOptions.filter(option => option.key !== q.correct_answer);
                otherCorrectOptions.push({ key: currentCorrectKey, value: currentCorrectValue });

                const uniqueOptionsMap = {};
                otherCorrectOptions.forEach(opt => { uniqueOptionsMap[opt.value] = opt; });
                let uniqueOptions = Object.values(uniqueOptionsMap);

                const maxOptions = Math.min(4, uniqueOptions.length);
                const selectedOptions = [];

                while (selectedOptions.length < maxOptions) {
                    const randIndex = Math.floor(Math.random() * uniqueOptions.length);
                    const option = uniqueOptions.splice(randIndex, 1)[0];
                    if (option.key == currentCorrectKey) {
                        option.key = tmpNo[selectedOptions.length];
                        q.correct_answer_actual = option.key
                    } else {
                        option.key = tmpNo[selectedOptions.length];
                    }
                    selectedOptions.push(option);
                }

                if (!selectedOptions.some(opt => opt.key === currentCorrectKey)) {
                    selectedOptions.pop();
                    selectedOptions.push({ key: currentCorrectKey, value: currentCorrectValue });
                }
                selectedOptions.sort(() => Math.random() - 0.5);
                optionsArray = selectedOptions.map(opt => [opt.key, opt.value]);
            }

            let idxNo = -1;
            let optionsHtml = "";
            for (let i = 0; i < optionsArray.length; i++) {
                const key = optionsArray[i][0];
                const value = optionsArray[i][1];
                idxNo++;
                const isLast = (idxNo === optionsArray.length - 1);
                const wrappedMeaning = await wrapWithMeaning(value);
                optionsHtml += `
                    <div data-index="${index}" style="display: flex; align-items: center; justify-content: space-between;">
                        <label style="flex: 1;">
                            <input type="radio" name="q${index}" value="${key}">
                            ${tmpNo[idxNo]}. ${wrappedMeaning}
                        </label>
                        ${isLast ? `
                            <button class="btn check-answer" data-index="${index}" style="padding: 6px 12px; font-size: 14px;">Ki·ªÉm tra</button>
                            <span class="tooltip-wrapper" style="position: relative; display: inline-block;">
                                <span class="explain-tooltip-icon disabled-tooltip" title="Xem gi·∫£i th√≠ch" data-index="${index}"
                                    style="display:none; cursor:pointer; font-size: 18px; color: #007bff;">üí°</span>
                                <div class="explain-tooltip-content">
                                    ${q.explanation || "Ch∆∞a c√≥ gi·∫£i th√≠ch."}
                                </div>
                            </span>
                        ` : ''}
                    </div>
                `;
            }

            const imageHtml = q.image ? `<img src="${q.image}" alt="Question Image" style="max-width: 100%; height: auto; margin-top: 10px;">` : '';
            let correctCountDisplay = "";
            const savedWrongEntry = savedWrongQuestions.find(entry => entry.question === q.question);
            if (savedWrongEntry) {
                correctCountDisplay = `<span id="spnCorrectCount" title="L·∫ßn ƒë√∫ng li√™n ti·∫øp" style="display: inline-block; background-color: green; color: white; border-radius: 50%; width: 20px; height: 20px; line-height: 20px; text-align: center; font-weight: bold; margin-left: 10px; font-size: 12px;">${savedWrongEntry.correctCount}</span>`;
            }
            const wrappedQuestion = await wrapWithMeaning(q.question);
            $quiz.append(`
                <div class="question" style="position: relative;">
                    ${index + 1}. ${wrappedQuestion} ${correctCountDisplay}
                    <span class="translate-icon" data-index="${index}" title="D·ªãch c√¢u h·ªèi"
                        style="cursor:pointer; margin-left:10px; font-size:18px; color:#007bff;">üîÑ</span>
                    <span class="chatgpt-icon" data-index="${index}" title="H·ªèi ChatGPT"
                        style="cursor:pointer; margin-left:10px; font-size:18px; color:#28a745;">ü§ñ</span>
                    <div class="translation" style="color: #555; margin-top: 5px; display:none;"></div>
                    ${imageHtml}
                </div>
                <div class="options">${optionsHtml}</div>
                <hr>
            `);
        }
        updateQuizStatusBar();
    }

    /**
     * Gets the correct answer key for a given question object.
     * @param {object} selectedQuestion - The question object.
     * @returns {string} The correct answer key.
     */
    function getCorrectAnswer(selectedQuestion) {
        return selectedQuestion.correct_answer_actual !== undefined ?
               selectedQuestion.correct_answer_actual :
               selectedQuestion.correct_answer;
    }

    /**
     * Compares two arrays of options for equality.
     * @param {Array} lstObjA - First array of options.
     * @param {Array} lstObjB - Second array of options.
     * @returns {boolean} True if arrays are equal, false otherwise.
     */
    function compareOptions(lstObjA, lstObjB) {
        if (!Array.isArray(lstObjA) || !Array.isArray(lstObjB)) return false;
        if (lstObjA.length !== lstObjB.length) return false;
        for (let i = 0; i < lstObjA.length; i++) {
            if (lstObjA[i] !== lstObjB[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Adds or updates a question in savedWrongQuestions with correctCount tracking.
     * @param {object} questionObj - The question object to add/update.
     */
    function addToSavedWrongQuestions(questionObj) {
        let existing = savedWrongQuestions.find(q =>
            q.question === questionObj.question &&
            q.correct_answer === questionObj.correct_answer &&
            compareOptions(q.options, questionObj.options)
        );

        if (!existing) {
            let newQuestion = Object.assign({}, questionObj);
            newQuestion.correctCount = 0;
            savedWrongQuestions.push(newQuestion);
            saveWrongQuestionsToLocalStorage();
        }
    }

    /**
     * Removes a question from savedWrongQuestions.
     * @param {object} questionObj - The question object to remove.
     */
    function removeFromSavedWrongQuestions(questionObj) {
        const index = savedWrongQuestions.findIndex(q => q.question === questionObj.question);
        if (index !== -1) {
            savedWrongQuestions.splice(index, 1);
            saveWrongQuestionsToLocalStorage();
        }
    }

    // =========================================================================
    // 5. UI State & Utility Functions
    // =========================================================================

    /**
     * Shows a toast message.
     * @param {string} message - The message to display.
     * @param {number} duration - Duration in milliseconds (default: 3000).
     */
    function showToast(message, duration = 3000) {
        const $toast = $("#toast");
        $toast.text(message).addClass("show").show();
        setTimeout(() => {
            $toast.removeClass("show").hide();
        }, duration);
    }

    /**
     * Disables or enables shuffleAnswersOption based on order selection.
     */
    function updateShuffleAnswersOptionState() {
        const orderValue = $("input[name='order']:checked").val();
        if (orderValue === "ordered") {
            $("input[name='shuffleAnswersOption']").prop("disabled", true);
            $("input[name='shuffleAnswersOption'][value='normal']").prop("checked", true)
        } else {
            $("input[name='shuffleAnswersOption']").prop("disabled", false);
        }
    }

    /**
     * Updates the state of the "Check All" checkbox.
     */
    function updateCheckAllState() {
        const $allCheckboxes = $("input[name='jsonFiles']");
        const $checkedBoxes = $("input[name='jsonFiles']:checked");
        const $checkAll = $("#checkAllFiles");
        if ($checkedBoxes.length === $allCheckboxes.length) {
            $checkAll.prop("checked", true);
            $checkAll.prop("indeterminate", false);
        } else if ($checkedBoxes.length > 0) {
            $checkAll.prop("checked", false);
            $checkAll.prop("indeterminate", true);
        } else {
            $checkAll.prop("checked", false);
            $checkAll.prop("indeterminate", false);
        }
    }

    /**
     * Updates the text of the dropdown button based on selected files.
     */
    function updateDropdownButtonText() {
        const $checkedBoxes = $("input[name='jsonFiles']:checked");
        const $button = $("#dropdownButton");
        if ($checkedBoxes.length === 0) {
            $button.text('Ch·ªçn file JSON');
        } else if ($checkedBoxes.length === 1) {
            $button.text($checkedBoxes.first().parent().text().trim());
        } else {
            $button.text(`ƒê√£ ch·ªçn ${$checkedBoxes.length} file`);
        }
    }

    /**
     * Sets up event listeners for the dropdown menu.
     */
    function setupDropdownEvents() {
        const $dropdownButton = $('#dropdownButton');
        const $dropdownContent = $('#dropdownContent');

        $dropdownButton.off('click').on('click', function (e) {
            e.stopPropagation();
            if ($dropdownContent.is(':visible')) {
                $dropdownContent.hide();
                $dropdownButton.attr('aria-expanded', 'false');
            } else {
                $dropdownContent.show();
                $dropdownButton.attr('aria-expanded', 'true');
            }
        });

        $(document).off('click.dropdown').on('click.dropdown', function () {
            $dropdownContent.hide();
            $dropdownButton.attr('aria-expanded', 'false');
        });

        $dropdownContent.off('click').on('click', function (e) {
            e.stopPropagation();
        });
    }

    /**
     * Updates the visibility of the "Retry Saved Wrong" button.
     */
    function updateRetrySavedWrongButton() {
        const $btn = $("#retrySavedWrong");
        if (savedWrongQuestions.length > 0) {
            $btn.show();
        } else {
            $btn.hide();
        }
    }

    // =========================================================================
    // 6. Event Handlers
    // =========================================================================

    /**
     * Handles the click event for the "Start Quiz" button.
     */
    $("#startQuiz").click(function () {
        const selectedFiles = $("input[name='jsonFiles']:checked").map(function () {
            return this.value;
        }).get();

        if (selectedFiles.length === 0) {
            showToast("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt file JSON!");
            return;
        }
        wrongQuestions = [];
        $("#retryWrong").hide();

        Promise.all(selectedFiles.map(f => $.getJSON(`../file/quiz/${f}`)))
            .then(fileDataList => {
                questions = fileDataList.flat();
                if (questions.length === 0) {
                    showToast("Kh√¥ng c√≥ c√¢u h·ªèi n√†o!");
                    return;
                }

                let start = parseInt($("#startQuestion").val()) || 1;
                let end = parseInt($("#endQuestion").val()) || questions.length;

                if (isInit) {
                    isInit = false;
                    endQuenstionInit = (end - start) + 1;
                }

                if (start === 0) {
                    start = 1;
                }

                if (start < 1 || end > questions.length || start > end) {
                    showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questions.length} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                    $('#continueQuiz').hide();
                    return;
                }

                selectedQuestions = questions.slice(start - 1, end);

                if ($("input[name='order']:checked").val() === "random") {
                    selectedQuestions = selectedQuestions.sort(() => Math.random() - 0.5);
                    const questionCount = Math.min(
                        parseInt($("#randomQuestionCount").val()) || selectedQuestions.length,
                        selectedQuestions.length
                    );
                    selectedQuestions = selectedQuestions.slice(0, questionCount);
                }

                renderQuiz();
                $("#quizContainer").show();
                $('.settings').hide();
                $('#startQuiz').hide();
                $('#retrySavedWrong').hide();
                startQuizTimer($('#quizDuration').val());

                const numberQuestion = (end - start) + 1;
                $("#continueQuiz").text(`L√†m ti·∫øp ${numberQuestion} c√¢u ti·∫øp`);
            })
            .catch(e => {
                console.error(e);
                showToast("L·ªói khi load file JSON!");
            });
    });

    /**
     * Handles the click event for the "Check Answer" button.
     */
    $(document).on("click", ".check-answer", function () {
        const $this = $(this);
        const index = $this.data("index");
        const selected = $(`input[name='q${index}']:checked`).val();
        const correct = getCorrectAnswer(selectedQuestions[index]);

        if (!selected) {
            showToast("Vui l√≤ng ch·ªçn m·ªôt ƒë√°p √°n tr∆∞·ªõc khi ki·ªÉm tra!");
            return;
        }

        $(`input[name='q${index}']`).prop("disabled", true);
        $(`input[name='q${index}'][value='${correct}']`).parent().addClass("correct");

        const questionObj = selectedQuestions[index];
        let savedWrongEntry = savedWrongQuestions.find((q) =>
            q.question === questionObj.question &&
            q.correct_answer === questionObj.correct_answer &&
            compareOptions(q.options, questionObj.options)
        );

        if (selected !== correct) {
            $(`input[name='q${index}'][value='${selected}']`).parent().addClass("incorrect");
            if (!wrongQuestions.includes(questionObj)) {
                wrongQuestions.push(questionObj);
            }
            if (savedWrongEntry) {
                savedWrongEntry.correctCount = 0;
            } else {
                addToSavedWrongQuestions(questionObj);
            }
        } else {
            if (savedWrongEntry) {
                savedWrongEntry.correctCount++;
                $this.parent().parent().prev().find('#spnCorrectCount').text(`${savedWrongEntry.correctCount}`);
                if (savedWrongEntry.correctCount >= 3) {
                    removeFromSavedWrongQuestions(questionObj);
                    if (wrongQuestions.includes(questionObj)) {
                        const indexRemove = wrongQuestions.indexOf(questionObj);
                        wrongQuestions.splice(indexRemove, 1);
                    }
                    if (savedWrongQuestions.length == 0) {
                        $('#resetting').click();
                    }
                }
            }
            if (wrongQuestions.includes(questionObj)) {
                const indexRemove = wrongQuestions.indexOf(questionObj);
                wrongQuestions.splice(indexRemove, 1);
            }
        }

        saveWrongQuestionsToLocalStorage();
        updateQuizStatusBar();
        if (wrongQuestions.length > 0) {
            $("#retryWrong").show();
        } else {
            $("#retryWrong").hide();
        }
        $(`.explain-tooltip-icon[data-index='${index}']`).show();
        $this.hide();
    });

    /**
     * Handles the click event for the "Submit Quiz" button.
     */
    $("#submitQuiz").click(function () {
        let score = 0;
        wrongQuestions = [];

        selectedQuestions.forEach((q, index) => {
            const userAnswer = $(`input[name='q${index}']:checked`).val();
            let correctAnswer = getCorrectAnswer(q);

            if (userAnswer === correctAnswer) {
                score++;
                $(`input[name='q${index}'][value='${correctAnswer}']`).parent().addClass("correct");
                removeFromSavedWrongQuestions(q);
            } else {
                $(`input[name='q${index}'][value='${correctAnswer}']`).parent().addClass("correct");
                if (userAnswer) {
                    $(`input[name='q${index}'][value='${userAnswer}']`).parent().addClass("incorrect");
                }
                wrongQuestions.push(q);
                addToSavedWrongQuestions(q);
            }
            $(`input[name='q${index}']`).prop("disabled", true);
        });

        updateQuizStatusBar();

        if (wrongQuestions.length > 0) {
            $("#retryWrong").show();
        } else {
            showToast("B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng t·∫•t c·∫£ c√°c c√¢u h·ªèi üéâ");
        }
    });

    /**
     * Handles the click event for the "Settings" button.
     */
    $("#resetting").click(function () {
        window.scrollTo(0, 0);
        $('.settings').show();
        $('#startQuiz').show();
        $('#quizContainer').hide();
        updateRetrySavedWrongButton();
        isRetrySavedWrongMode = false; // Reset mode when going back to settings
    });

    /**
     * Loads quiz options (categories and file names).
     */
    function loadOptions() {
        const listFileName = `../file/quiz/data-file-name.json`;
        $.getJSON(listFileName)
            .done(data => {
                const $categoryContainer = $('#categoryRadio');
                $categoryContainer.empty();
                allFileNames = data.map(u => u.value);
                dataFileJson = data;

                const categories = [...new Set(data.map(item => item.category))];
                categories.forEach(cat => {
                    const $catRadio = $('<input>', {
                        type: 'radio',
                        name: 'categoryFilter',
                        value: cat,
                        id: `cat_${cat.replace(/\s+/g, '_')}`
                    });
                    const $catLabel = $('<label>', {
                        for: $catRadio.attr('id'),
                        style: 'margin-right: 10px;'
                    }).append($catRadio).append(` ${cat}`);
                    $categoryContainer.append($catLabel);
                });

                renderFileCheckboxes();
                $(document).off('change', "input[name='categoryFilter']").on('change', "input[name='categoryFilter']", renderFileCheckboxes);
            })
            .fail(err => {
                showToast("L·ªói khi t·∫£i file JSON: " + err.statusText);
            });
    }

    /**
     * Renders file checkboxes based on the selected category.
     */
    function renderFileCheckboxes() {
        const $selectedCategory = $("input[name='categoryFilter']:checked");
        const $container = $('#fileListCheckboxes');
        $container.html('<label><input type="checkbox" id="checkAllFiles"><em>Ch·ªçn t·∫•t c·∫£</em></label>');

        let filteredData = [];
        if ($selectedCategory.length > 0) {
            filteredData = dataFileJson.filter(item => item.category === $selectedCategory.val());
        }

        filteredData.forEach(item => {
            const $checkbox = $('<input>', {
                type: 'checkbox',
                name: 'jsonFiles',
                value: item.value,
                id: `chk_${item.value}`
            });
            const $label = $('<label>', {
                for: $checkbox.attr('id')
            }).append($checkbox).append(` ${item.key}`);
            $container.append($label);
        });

        $('#checkAllFiles').off('change').on('change', function () {
            const checked = this.checked;
            $("input[name='jsonFiles']").prop('checked', checked);
            updateDropdownButtonText();
            saveSettingsToLocalStorage();
        });

        $container.find("input[name='jsonFiles']").off('change').on('change', function () {
            updateCheckAllState();
            updateDropdownButtonText();
            saveSettingsToLocalStorage();
        });

        updateCheckAllState();
        updateDropdownButtonText();
    }

    /**
     * Handles the click event for the "Retry Wrong" button.
     */
    $("#retryWrong").click(function () {
        if (wrongQuestions.length === 0) {
            showToast("Kh√¥ng c√≥ c√¢u sai ƒë·ªÉ l√†m l·∫°i.");
            return;
        }
        selectedQuestions = [...wrongQuestions];
        renderQuiz();
        updateQuizStatusBar();
        $(this).hide();
    });

    /**
     * Handles the click event for the "Retry Saved Wrong" button.
     */
    $("#retrySavedWrong").click(function () {
        if (savedWrongQuestions.length === 0) {
            showToast("Kh√¥ng c√≥ c√¢u sai ƒë√£ l∆∞u ƒë·ªÉ l√†m l·∫°i.");
            return;
        }
        isRetrySavedWrongMode = true;
        $("#quizContainer").show();
        $('.settings').hide();
        $('#startQuiz').hide();
        let numberQuestion = (parseInt($("#endQuestion").val()) || questions.length) - (parseInt($("#startQuestion").val()) || 1) + 1;
        $("#continueQuiz").text(`L√†m ti·∫øp ${numberQuestion} c√¢u ti·∫øp`);
        selectedQuestions = [...savedWrongQuestions];
        renderQuiz();
        updateQuizStatusBar();
        $(this).hide();
    });

    /**
     * Handles the click event for the "Retest" button.
     */
    $("#retest").click(function () {
        if (isRetrySavedWrongMode) {
            selectedQuestions = [...savedWrongQuestions];
        } else {
            selectedQuestions = selectedQuestions.slice();
        }
        renderQuiz();
        updateQuizStatusBar();
        $(this).blur();
    });

    /**
     * Handles the click event for the "Continue Quiz" button.
     */
    $("#continueQuiz").click(function () {
        const $startQuestion = $("#startQuestion");
        const $endQuestion = $("#endQuestion");
        const $continueQuiz = $("#continueQuiz");
        const questionsLength = questions.length;

        let start = parseInt($startQuestion.val()) || 1;
        let end = parseInt($endQuestion.val()) || questionsLength;

        const beforeEnd = end;

        start += endQuenstionInit;
        end += endQuenstionInit;

        if (end > questionsLength) {
            if (beforeEnd === questionsLength && end > questionsLength) {
                showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questionsLength} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                $continueQuiz.hide();
                return;
            }
            start = beforeEnd + 1;
            end = questionsLength;
        } else {
            if (start < 1 || end > questionsLength || start > end) {
                showToast(`Vui l√≤ng ch·ªçn kho·∫£ng t·ª´ 1 ƒë·∫øn ${questionsLength} v√† ƒë·∫£m b·∫£o 'T·ª´ c√¢u' nh·ªè h∆°n 'ƒê·∫øn c√¢u'.`);
                $continueQuiz.hide();
                return;
            }
        }

        $startQuestion.val(start);
        $endQuestion.val(end);
        $continueQuiz.text(`L√†m ti·∫øp ${endQuenstionInit} c√¢u ti·∫øp`);

        $("#startQuiz").click();
    });

    /**
     * Handles the click event for the ChatGPT icon.
     */
    $(document).on('click', '.chatgpt-icon', function () {
        const $this = $(this);
        const index = $this.data('index');
        const questionObj = selectedQuestions[index];

        let fullText = `1. D·ªãch v·ª´a c√≥ ti·∫øng anh v√† ti·∫øng vi·ªát\n`;
        fullText += `2. Tr√≠ch d·∫´n t·ª´ BABOK V3 ·ªü c√¢u ƒë√∫ng\n`;
        fullText += `C√¢u h·ªèi: ${questionObj.question}\n`;

        for (const key in questionObj.options) {
            fullText += `${key}. ${questionObj.options[key]}\n`;
        }

        fullText += `\nƒê√°p √°n c·ªßa t√¥i l√†: ${questionObj.correct_answer}`;

        navigator.clipboard.writeText(fullText)
            .then(() => {
                window.open("https://chatgpt.com/?temporary-chat=true", '_blank');
            })
            .catch(err => {
                showToast("Kh√¥ng th·ªÉ copy v√†o clipboard. Vui l√≤ng th·ª≠ l·∫°i.");
                console.error(err);
            });
    });

    /**
     * Handles the click event for the translate icon.
     */
    $(document).on('click', '.translate-icon', function () {
        const $this = $(this);
        const index = $this.data('index');
        const questionObj = selectedQuestions[index];

        let fullText = questionObj.question + '\n';
        for (const key in questionObj.options) {
            fullText += `${key}. ${questionObj.options[key]}\n`;
        }

        const url = `https://translate.google.com/?sl=en&tl=vi&text=${encodeURIComponent(fullText)}&op=translate`;
        window.open(url, '_blank');
    });

    /**
     * Handles mouse events for explanation tooltips.
     */
    (function() {
        let tooltipTimeout;
        $(document).on("mouseenter", ".explain-tooltip-icon", function () {
            const $this = $(this);
            if (!$this.hasClass("disabled-tooltip")) {
                clearTimeout(tooltipTimeout);
                $this.siblings(".explain-tooltip-content").stop(true, true).fadeIn(200);
            }
        }).on("mouseleave", ".explain-tooltip-icon", function () {
            const $this = $(this);
            tooltipTimeout = setTimeout(() => {
                $this.siblings(".explain-tooltip-content").stop(true, true).fadeOut(200);
            }, 300);
        });
    })();

    /**
     * Handles the click event for the Dark Mode toggle button.
     */
    const darkModeToggle = $('#darkModeToggle');
    const body = $('body');

    if (localStorage.getItem('darkMode') === 'enabled') {
        body.addClass('dark-mode');
    }

    darkModeToggle.off('click').on('click', function () {
        body.toggleClass('dark-mode');
        if (body.hasClass('dark-mode')) {
            localStorage.setItem('darkMode', 'enabled');
        } else {
            localStorage.setItem('darkMode', 'disabled');
        }
    });

</script>
<style>
    ruby {
      ruby-position: over;
    }

    ruby rb {
      font-size: 16px; /* l√†m nh·ªè Kanji */
      color: #28a745;
    }

    ruby rt {
      font-size: 8px; /* ho·∫∑c c√πng k√≠ch th∆∞·ªõc v·ªõi rb */
      color: #555;
      padding: 0px 0px 1px 0px;
    }

    #timer {
        position: fixed;
        top: 50px; /* Adjust as needed to avoid overlap with other elements */
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        z-index: 4000;
        font-weight: bold;
        font-size: 18px;
        margin-top: 0;
        display: none; /* Keep initial hidden, JS will show it */
    }

    body:not(.dark-mode) #timer {
        background-color: rgba(255, 255, 255, 0.9);
        color: black;
    }
</style>
</body>
</html>