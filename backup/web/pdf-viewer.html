<!doctype html>
<html lang="vi">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>PDF Viewer</title>
	<style>
		:root {
			--bg: #0f1115;
			--fg: #e6e6e6;
			--muted: #9aa3b2;
			--accent: #3b82f6;
		}
		html, body {
			height: 100%;
			margin: 0;
			background: var(--bg);
			color: var(--fg);
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
		}
		.viewer {
			display: grid;
			grid-template-rows: auto 1fr auto;
			height: 100%;
		}
		.toolbar {
			display: flex;
			gap: 8px;
			align-items: center;
			padding: 10px;
			border-bottom: 1px solid #1d2330;
			background: #121621;
		}
		.toolbar button {
			appearance: none;
			border: 1px solid #2a3142;
			background: #192033;
			color: var(--fg);
			border-radius: 8px;
			padding: 8px 12px;
			cursor: pointer;
			font-weight: 600;
		}
		.toolbar button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}
		.toolbar input[type="number"] {
			width: 72px;
			background: #111726;
			border: 1px solid #2a3142;
			color: var(--fg);
			border-radius: 8px;
			padding: 8px 10px;
		}
		.page-info { color: var(--muted); }

		.canvas-wrap {
			overflow: auto;
			display: grid;
			place-items: center;
			background: #0b0e17;
		}
		.page-surface { position: relative; }
		canvas { background: white; box-shadow: 0 10px 30px rgba(0,0,0,0.35); display: block; }
		#textLayer {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			color: transparent;
			mix-blend-mode: multiply;
		}
		#textLayer span {
			position: absolute;
			white-space: pre;
			transform-origin: 0% 0%;
			pointer-events: auto;
			user-select: text;
			-webkit-user-select: text;
		}
		/* Horizontal guide line at 20% height */
		.guide-line {
			position: absolute;
			left: 0;
			right: 0;
			height: 8px;
			pointer-events: none;
			z-index: 5;
		}
		/* Shaded band between From% and To% */
		.guide-band {
			position: absolute;
			left: 0;
			right: 0;
			pointer-events: none;
			z-index: 4;
		}

		.footer {
			padding: 8px 10px;
			border-top: 1px solid #1d2330;
			background: #121621;
			color: var(--muted);
			font-size: 12px;
		}
		.footer a { color: var(--accent); text-decoration: none; }
	</style>

	<!-- PDF.js via CDN -->
	<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
	<script>
		// Configure worker from CDN
		pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
	</script>
</head>
<body>
	<div class="viewer">
		<div class="toolbar">
			<button id="openBtn" title="Chọn file PDF">Mở PDF</button>
			<input id="fileInput" type="file" accept="application/pdf" hidden />
			<label style="display:flex; align-items:center; gap:6px; color: var(--muted);">
				<span>Bài</span>
				<select id="lessonSelect" style="background:#111726;border:1px solid #2a3142;color:var(--fg);border-radius:8px;padding:8px 10px; min-width: 110px;"></select>
			</label>
			<button id="prevBtn" disabled>Prev</button>
			<button id="nextBtn" disabled>Next</button>
			<div class="page-info">
				<span>Trang</span>
				<input id="pageNumber" type="number" min="1" value="1" />
				<span>/ <span id="pageCount">0</span></span>
			</div>
			<div style="flex:1"></div>
			<label style="display:flex; align-items:center; gap:6px; color: var(--muted);">
				<span>Zoom</span>
				<input id="zoomInput" type="number" min="25" max="400" step="5" value="100" style="width:84px;background:#111726;border:1px solid #2a3142;color:var(--fg);border-radius:8px;padding:8px 10px;" />
			</label>
			<label style="display:flex; align-items:center; gap:6px; color: var(--muted); margin-left:12px;">
				<span>Mode</span>
				<select id="rangeSelect" style="background:#111726;border:1px solid #2a3142;color:var(--fg);border-radius:8px;padding:8px 10px; min-width: 140px;">
					<option value="study">Study</option>
					<option value="easy">Easy</option>
					<option value="normal">Normal</option>
					<option value="hard">Hard</option>
					<option value="very.hard">Very hard</option>
				</select>
			</label>
			<label style="display:flex; align-items:center; gap:6px; color: var(--muted); margin-left:12px;">
				<input id="randomCheckbox" type="checkbox" style="transform: scale(1.2);" />
				<span>Random</span>
			</label>
			<button id="bookmarkBtn" title="Đánh dấu trang hiện tại">📖</button>
			<div id="bookmarkDropdown" style="position: relative; display: inline-block;">
				<button id="bookmarkListBtn" title="Danh sách bookmark">📚</button>
				<div id="bookmarkMenu" style="display: none; position: absolute; top: 100%; right: 0; background: #192033; border: 1px solid #2a3142; border-radius: 8px; min-width: 200px; max-height: 300px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
					<div style="padding: 8px 12px; border-bottom: 1px solid #2a3142; color: var(--muted); font-size: 12px; font-weight: 600;">Bookmarks</div>
					<div id="bookmarkList"></div>
				</div>
			</div>
		</div>

		<div class="canvas-wrap" id="canvasWrap">
			<div class="page-surface">
				<canvas id="pdfCanvas"></canvas>
				<div id="textLayer" class="textLayer"></div>
				<div id="guideBand" class="guide-band"></div>
				<div id="guideFromLine" class="guide-line"></div>
				<div id="guideToLine" class="guide-line"></div>
				<div id="bookmarkIndicator" style="position: absolute; top: 10px; right: 10px; background: rgba(59, 130, 246, 0.9); color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: 600; display: none; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">🔖 Bookmarked</div>
			</div>
		</div>
	</div>

	<script>
		(function () {
			const canvas = document.getElementById('pdfCanvas');
			const ctx = canvas.getContext('2d');
			const textLayerDiv = document.getElementById('textLayer');
			const canvasWrap = document.getElementById('canvasWrap');
			const prevBtn = document.getElementById('prevBtn');
			console.log('prevBtn element:', prevBtn);
			const nextBtn = document.getElementById('nextBtn');
			const pageNumberInput = document.getElementById('pageNumber');
			const pageCountEl = document.getElementById('pageCount');
			const openBtn = document.getElementById('openBtn');
			const fileInput = document.getElementById('fileInput');
			const zoomInput = document.getElementById('zoomInput');
			const lessonSelect = document.getElementById('lessonSelect');
			const guideBand = document.getElementById('guideBand');
			const guideFromLine = document.getElementById('guideFromLine');
			const guideToLine = document.getElementById('guideToLine');
			const rangeSelect = document.getElementById('rangeSelect');
			const randomCheckbox = document.getElementById('randomCheckbox');
			const bookmarkBtn = document.getElementById('bookmarkBtn');
			const bookmarkListBtn = document.getElementById('bookmarkListBtn');
			const bookmarkMenu = document.getElementById('bookmarkMenu');
			const bookmarkList = document.getElementById('bookmarkList');
			const bookmarkIndicator = document.getElementById('bookmarkIndicator');

			let pdfDoc = null;
			let currentPageNumber = 1;
			let totalPages = 0;
			const ZOOM_STORAGE_KEY = 'pdf_viewer_zoom_percent';
			const LAST_FILE_KEY = 'pdf_viewer_last_file';
			let zoom = 1;
			let renderingInProgress = false;
			let pendingPageNumber = null;
			let currentFilePath = '';
			let scrollSaveTimer = null;
			const RANGE_SELECT_KEY = 'pdf_range_select_value';
			const GUIDE_COVER_KEY = 'pdf_guide_cover_enabled';
			const RANDOM_CHECKBOX_KEY = 'pdf_random_checkbox_enabled';
			const BOOKMARKS_KEY = 'pdf_bookmarks';
			const LESSON_SELECT_KEY = 'pdf_lesson_select_value';

			function clampPercent(v) { return Math.max(0, Math.min(100, v)); }

			function getGuidePercents() {
				const selection = (rangeSelect && rangeSelect.value) || 'study';
				switch (selection) {
					case 'easy':
						return { start: 86, end: 100 };
					case 'normal':
						return { start: 57, end: 85 };
					case 'hard':
						return { start: 57, end: 100 };
					case 'very.hard':
					    return { start: 57, end: 75 };
					case 'study':
					default:
						return { start: 0, end: 0 };
				}
			}

			function saveRangeSelection() {
				if (!rangeSelect) return;
				try { localStorage.setItem(RANGE_SELECT_KEY, rangeSelect.value); } catch {}
			}

			function restoreRangeSelection() {
				let val = 'study';
				try { val = localStorage.getItem(RANGE_SELECT_KEY) || 'study'; } catch {}
				if (rangeSelect) rangeSelect.value = val;
			}

			function saveRandomCheckbox() {
				if (!randomCheckbox) return;
				try { localStorage.setItem(RANDOM_CHECKBOX_KEY, randomCheckbox.checked ? 'true' : 'false'); } catch {}
			}

			function restoreRandomCheckbox() {
				let val = false;
				try { val = localStorage.getItem(RANDOM_CHECKBOX_KEY) === 'true'; } catch {}
				if (randomCheckbox) randomCheckbox.checked = val;
			}

			// Bookmark functions
			function getBookmarks() {
				try {
					const bookmarks = localStorage.getItem(BOOKMARKS_KEY);
					return bookmarks ? JSON.parse(bookmarks) : {};
				} catch {
					return {};
				}
			}

			function saveBookmarks(bookmarks) {
				try {
					localStorage.setItem(BOOKMARKS_KEY, JSON.stringify(bookmarks));
				} catch (err) {
					console.log('Could not save bookmarks:', err);
				}
			}

			function getCurrentFileKey() {
				return currentFilePath || 'unknown';
			}

			function addBookmark(pageNumber) {
				const bookmarks = getBookmarks();
				const fileKey = getCurrentFileKey();
				const bookmarkKey = `${fileKey}:${pageNumber}`;
				
				if (!bookmarks[bookmarkKey]) {
					bookmarks[bookmarkKey] = {
						file: fileKey,
						page: pageNumber,
						timestamp: Date.now()
					};
					saveBookmarks(bookmarks);
					updateBookmarkUI();
					
					// Update bookmark list if it's currently visible
					if (bookmarkMenu && bookmarkMenu.style.display === 'block') {
						renderBookmarkList();
					}
					
					// If we're in bookmark lesson mode, refresh the lesson
					if (lessonSelect && lessonSelect.value === 'bookmarks') {
						loadBookmarksLesson();
					}
				}
			}

			function removeBookmark(pageNumber) {
				const bookmarks = getBookmarks();
				const fileKey = getCurrentFileKey();
				const bookmarkKey = `${fileKey}:${pageNumber}`;
				
				if (bookmarks[bookmarkKey]) {
					delete bookmarks[bookmarkKey];
					saveBookmarks(bookmarks);
					updateBookmarkUI();
					
					// Update bookmark list if it's currently visible
					if (bookmarkMenu && bookmarkMenu.style.display === 'block') {
						renderBookmarkList();
					}
					
					// If we're in bookmark lesson mode, refresh the lesson
					if (lessonSelect && lessonSelect.value === 'bookmarks') {
						loadBookmarksLesson();
					}
				}
			}

			function isBookmarked(pageNumber) {
				const bookmarks = getBookmarks();
				const fileKey = getCurrentFileKey();
				const bookmarkKey = `${fileKey}:${pageNumber}`;
				return !!bookmarks[bookmarkKey];
			}

			function updateBookmarkUI() {
				if (!bookmarkBtn) return;
				const isCurrentBookmarked = isBookmarked(currentPageNumber);
				bookmarkBtn.textContent = isCurrentBookmarked ? '🔖' : '📖';
				bookmarkBtn.title = isCurrentBookmarked ? 'Bỏ đánh dấu trang này' : 'Đánh dấu trang này';
				
				// Show/hide bookmark indicator
				if (bookmarkIndicator) {
					bookmarkIndicator.style.display = isCurrentBookmarked ? 'block' : 'none';
				}
			}

			function renderBookmarkList() {
				if (!bookmarkList) return;
				const bookmarks = getBookmarks();
				
				bookmarkList.innerHTML = '';
				
				// Convert bookmarks object to array and sort by timestamp (oldest first)
				const bookmarkArray = Object.values(bookmarks).sort((a, b) => a.timestamp - b.timestamp);
				
				if (bookmarkArray.length === 0) {
					const emptyItem = document.createElement('div');
					emptyItem.style.padding = '12px';
					emptyItem.style.color = 'var(--muted)';
					emptyItem.style.fontSize = '12px';
					emptyItem.style.textAlign = 'center';
					emptyItem.textContent = 'Chưa có bookmark nào';
					bookmarkList.appendChild(emptyItem);
					return;
				}

				bookmarkArray.forEach(bookmark => {
					const item = document.createElement('div');
					item.style.display = 'flex';
					item.style.justifyContent = 'space-between';
					item.style.alignItems = 'center';
					item.style.padding = '8px 12px';
					item.style.borderBottom = '1px solid #2a3142';
					item.style.cursor = 'pointer';
					item.style.fontSize = '13px';
					
					const bookmarkInfo = document.createElement('div');
					bookmarkInfo.style.display = 'flex';
					bookmarkInfo.style.flexDirection = 'column';
					bookmarkInfo.style.gap = '2px';
					
					const fileName = document.createElement('span');
					fileName.style.fontSize = '11px';
					fileName.style.color = 'var(--muted)';
					fileName.textContent = bookmark.file.replace('storage/japan/', '').replace('.pdf', '');
					
					const pageInfo = document.createElement('span');
					pageInfo.textContent = `Trang ${bookmark.page}`;
					if (bookmark.file === getCurrentFileKey() && bookmark.page === currentPageNumber) {
						pageInfo.style.color = 'var(--accent)';
						pageInfo.style.fontWeight = '600';
					}
					
					bookmarkInfo.appendChild(fileName);
					bookmarkInfo.appendChild(pageInfo);
					
					const removeBtn = document.createElement('button');
					removeBtn.textContent = '×';
					removeBtn.style.background = 'none';
					removeBtn.style.border = 'none';
					removeBtn.style.color = 'var(--muted)';
					removeBtn.style.cursor = 'pointer';
					removeBtn.style.fontSize = '16px';
					removeBtn.style.padding = '2px 6px';
					removeBtn.style.borderRadius = '4px';
					removeBtn.title = 'Xóa bookmark';
					
					item.appendChild(bookmarkInfo);
					item.appendChild(removeBtn);
					
					// Click to go to page (and load file if needed)
					item.addEventListener('click', (e) => {
						if (e.target !== removeBtn) {
							console.log('Bookmark item clicked:', bookmark);
							
							// If we're in bookmark lesson mode, find the index and go to it
							if (lessonSelect && lessonSelect.value === 'bookmarks') {
								const targetIndex = bookmarkLessonData.findIndex(b => 
									b.file === bookmark.file && b.page === bookmark.page
								);
								if (targetIndex !== -1) {
									console.log('Found bookmark at index:', targetIndex);
									currentBookmarkIndex = targetIndex;
									loadCurrentBookmark();
									bookmarkMenu.style.display = 'none';
								} else {
									console.log('Bookmark not found in lesson data');
								}
							} else {
								// Normal mode - load file and go to page
								if (bookmark.file !== getCurrentFileKey()) {
									loadPdf(bookmark.file, true).then(() => {
										goToPage(bookmark.page);
										bookmarkMenu.style.display = 'none';
									}).catch(() => {
										console.log('Could not load file:', bookmark.file);
									});
								} else {
									goToPage(bookmark.page);
									bookmarkMenu.style.display = 'none';
								}
							}
						}
					});
					
					// Remove bookmark
					removeBtn.addEventListener('click', (e) => {
						e.stopPropagation();
						removeBookmark(bookmark.page);
					});
					
					bookmarkList.appendChild(item);
				});
			}

			// Bookmark lesson functionality
			let bookmarkLessonData = [];
			let currentBookmarkIndex = 0;

			// Save/restore lesson select value
			function saveLessonSelection() {
				if (!lessonSelect) return;
				try { 
					localStorage.setItem(LESSON_SELECT_KEY, lessonSelect.value); 
				} catch {}
			}

			function restoreLessonSelection() {
				if (!lessonSelect) return;
				try {
					const saved = localStorage.getItem(LESSON_SELECT_KEY);
					if (saved) {
						lessonSelect.value = saved;
						// If restored value is 'bookmarks', load bookmark lesson
						if (saved === 'bookmarks') {
							loadBookmarksLesson();
						}
					}
				} catch {}
			}

			function loadBookmarksLesson() {
				const bookmarks = getBookmarks();
				bookmarkLessonData = Object.values(bookmarks).sort((a, b) => a.timestamp - b.timestamp);
				currentBookmarkIndex = 0;
				
				if (bookmarkLessonData.length === 0) {
					// Show empty state
					showBookmarkEmptyState();
					return;
				}
				
				// Load first bookmark
				loadCurrentBookmark();
			}

			function showBookmarkEmptyState() {
				// Clear canvas and show message
				canvas.width = 900;
				canvas.height = 200;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = '#111';
				ctx.font = '20px Segoe UI, Roboto, Arial';
				ctx.fillText('Chưa có bookmark nào để học', 20, 80);
				ctx.font = '14px Segoe UI, Roboto, Arial';
				ctx.fillText('Hãy đánh dấu một số trang để tạo bài học bookmark', 20, 110);
				
				// Update UI
				totalPages = 0;
				pageCountEl.textContent = '0';
				pageNumberInput.value = '0';
				updateButtons();
				updateBookmarkUI();
			}

			function loadCurrentBookmark() {
				if (bookmarkLessonData.length === 0) return;
				
				const bookmark = bookmarkLessonData[currentBookmarkIndex];
				console.log('Loading bookmark:', {
					index: currentBookmarkIndex,
					bookmark: bookmark,
					file: bookmark.file,
					page: bookmark.page
				});
				
				currentFilePath = bookmark.file;
				
				// Load the actual PDF file first
				loadPdf(bookmark.file, true).then(() => {
					console.log('PDF loaded, updating UI...');
					
					// Override totalPages after loadPdf (which might have changed it)
					totalPages = bookmarkLessonData.length;
					pageCountEl.textContent = String(totalPages);
					
					// Update page number input to show bookmark index
					pageNumberInput.value = String(currentBookmarkIndex + 1);
					
					// Go to the specific bookmarked page
					currentPageNumber = bookmark.page;
					queueRender(bookmark.page);
					
					updateButtons();
					updateBookmarkUI();
					
					// Debug info
					console.log('Bookmark lesson updated:', {
						bookmarkIndex: currentBookmarkIndex + 1,
						totalBookmarks: bookmarkLessonData.length,
						pdfPage: bookmark.page,
						file: bookmark.file,
						displayText: `Trang ${currentBookmarkIndex + 1} / ${bookmarkLessonData.length}`
					});
				}).catch((err) => {
					console.log('Could not load bookmark file:', bookmark.file, err);
				});
			}

			function goToNextBookmark() {
				if (bookmarkLessonData.length === 0) return;
				
				console.log('Before Next:', {
					currentIndex: currentBookmarkIndex,
					totalBookmarks: bookmarkLessonData.length,
					currentBookmark: bookmarkLessonData[currentBookmarkIndex]
				});
				
				if (currentBookmarkIndex < bookmarkLessonData.length - 1) {
					currentBookmarkIndex++;
				} else {
					// If at the end, loop back to the beginning
					currentBookmarkIndex = 0;
				}
				
				console.log('After Next:', {
					newIndex: currentBookmarkIndex,
					newBookmark: bookmarkLessonData[currentBookmarkIndex]
				});
				
				loadCurrentBookmark();
			}

			function goToPrevBookmark() {
				if (bookmarkLessonData.length === 0) return;
				
				console.log('Before Previous:', {
					currentIndex: currentBookmarkIndex,
					totalBookmarks: bookmarkLessonData.length,
					currentBookmark: bookmarkLessonData[currentBookmarkIndex]
				});
				
				if (currentBookmarkIndex > 0) {
					currentBookmarkIndex--;
					console.log('After Previous:', {
						newIndex: currentBookmarkIndex,
						newBookmark: bookmarkLessonData[currentBookmarkIndex]
					});
					loadCurrentBookmark();
				} else {
					console.log('Already at first bookmark, cannot go previous');
				}
			}

			function updateGuideOverlay(viewportWidth, viewportHeight) {
				const { start, end } = getGuidePercents();
				const thickness = 8;
				if (guideFromLine && guideToLine && guideBand) {
					guideFromLine.style.display = 'block';
					guideToLine.style.display = 'block';
					guideBand.style.display = 'block';
					guideFromLine.style.width = viewportWidth + 'px';
					guideToLine.style.width = viewportWidth + 'px';
					guideFromLine.style.height = thickness + 'px';
					guideToLine.style.height = thickness + 'px';
					const y1 = Math.round(viewportHeight * (start / 100));
					const y2 = Math.round(viewportHeight * (end / 100));
					guideFromLine.style.top = Math.max(0, y1 - Math.floor(thickness / 2)) + 'px';
					guideToLine.style.top = Math.max(0, y2 - Math.floor(thickness / 2)) + 'px';
					guideBand.style.top = Math.min(y1, y2) + 'px';
					guideBand.style.height = Math.max(0, Math.abs(y2 - y1)) + 'px';
					guideBand.style.width = viewportWidth + 'px';
					// Cover mode: make band opaque and on top, else translucent
					guideBand.style.background = 'rgba(0,0,0,0.95)';
					guideBand.style.zIndex = '7';
				}
			}

			function makeScrollKey() {
				return 'pdf_scroll_position';
			}

			function saveScrollPosition() {
				if (!canvasWrap) return;
				const maxScroll = Math.max(1, canvasWrap.scrollHeight - canvasWrap.clientHeight);
				const ratio = canvasWrap.scrollTop / maxScroll;
				try { localStorage.setItem(makeScrollKey(), String(ratio)); } catch {}
			}

			function restoreScrollPosition() {
				if (!canvasWrap) return;
				let saved = null;
				try { saved = localStorage.getItem(makeScrollKey()); } catch {}
				const ratio = saved ? parseFloat(saved) : 0;
				if (Number.isFinite(ratio)) {
					const maxScroll = Math.max(1, canvasWrap.scrollHeight - canvasWrap.clientHeight);
					canvasWrap.scrollTop = Math.round(maxScroll * Math.max(0, Math.min(ratio, 1)));
				}
			}

			// Save while scrolling (debounced)
			canvasWrap.addEventListener('scroll', () => {
				if (scrollSaveTimer) clearTimeout(scrollSaveTimer);
				scrollSaveTimer = setTimeout(() => { saveScrollPosition(); }, 200);
			});

			// Save on page unload as a last chance
			window.addEventListener('beforeunload', () => { saveScrollPosition(); });


			function updateButtons() {
				// Check if we're in bookmark lesson mode
				if (lessonSelect && lessonSelect.value === 'bookmarks') {
					// In bookmark lesson mode, only disable based on position, not rendering
					prevBtn.disabled = !pdfDoc || currentBookmarkIndex <= 0;
					nextBtn.disabled = !pdfDoc || currentBookmarkIndex >= bookmarkLessonData.length - 1;
					pageNumberInput.disabled = !pdfDoc || renderingInProgress;
					zoomInput.disabled = !pdfDoc || renderingInProgress;
					
					console.log('updateButtons (bookmark mode):', {
						currentBookmarkIndex: currentBookmarkIndex,
						totalBookmarks: bookmarkLessonData.length,
						prevBtnDisabled: prevBtn.disabled,
						nextBtnDisabled: nextBtn.disabled,
						pdfDoc: !!pdfDoc,
						renderingInProgress: renderingInProgress
					});
				} else {
					prevBtn.disabled = !pdfDoc || currentPageNumber <= 1 || renderingInProgress;
					nextBtn.disabled = !pdfDoc || currentPageNumber >= totalPages || renderingInProgress;
					pageNumberInput.disabled = !pdfDoc || renderingInProgress;
					zoomInput.disabled = !pdfDoc || renderingInProgress;
				}
			}

			async function renderPage(pageNum) {
				renderingInProgress = true;
				// Don't update buttons here to avoid conflicts
				try {
					const page = await pdfDoc.getPage(pageNum);
					const viewport = page.getViewport({ scale: zoom });
					canvas.width = viewport.width;
					canvas.height = viewport.height;
					// Resize text layer container to match canvas
					textLayerDiv.style.width = viewport.width + 'px';
					textLayerDiv.style.height = viewport.height + 'px';
					textLayerDiv.innerHTML = '';
					// Update guide overlays based on From/To percents
					updateGuideOverlay(viewport.width, viewport.height);
					const renderContext = { canvasContext: ctx, viewport };
					await page.render(renderContext).promise;
					// Render selectable text layer
					const textContent = await page.getTextContent();
					// Set the scale factor CSS variable for text layer
					textLayerDiv.style.setProperty('--scale-factor', viewport.scale);
					await pdfjsLib.renderTextLayer({
						textContentSource: textContent,
						container: textLayerDiv,
						viewport,
						enhanceTextSelection: true,
						textDivs: []
					}).promise;
					// Restore scroll after DOM is updated this frame
					requestAnimationFrame(() => { restoreScrollPosition(); });
				} finally {
					renderingInProgress = false;
					
					// Update UI for bookmark lesson mode
					if (lessonSelect && lessonSelect.value === 'bookmarks') {
						totalPages = bookmarkLessonData.length;
						pageCountEl.textContent = String(totalPages);
						pageNumberInput.value = String(currentBookmarkIndex + 1);
					}
					
					// Update buttons only once at the end
					updateButtons();
					
					if (pendingPageNumber !== null) {
						const next = pendingPageNumber;
						pendingPageNumber = null;
						renderPage(next);
					}
				}
			}

			function queueRender(pageNum) {
				if (renderingInProgress) {
					pendingPageNumber = pageNum;
				} else {
					renderPage(pageNum);
				}
			}

			function goToPage(pageNum) {
				if (!pdfDoc) return;
				// Save current scroll for current page before navigating
				saveScrollPosition();
				const clamped = Math.max(1, Math.min(pageNum, totalPages));
				currentPageNumber = clamped;
				try { localStorage.setItem('pdf_last_page', String(clamped)); } catch {}
				pageNumberInput.value = String(clamped);
				updateBookmarkUI(); // Update bookmark button state
				queueRender(clamped);
			}

			function goToNextPage() {
				if (!pdfDoc) return;
				
				// Check if we're in bookmark lesson mode
				if (lessonSelect && lessonSelect.value === 'bookmarks') {
					goToNextBookmark();
					return;
				}
				
				if (randomCheckbox && randomCheckbox.checked) {
					// Random page when checkbox is checked
					const randomPage = Math.floor(Math.random() * totalPages) + 1;
					goToPage(randomPage);
				} else {
					// Normal next page
					goToPage(currentPageNumber + 1);
				}
			}

			async function loadPdf(src, resetToPage1 = false) {
				const loadingTask = pdfjsLib.getDocument(src);
				pdfDoc = await loadingTask.promise;
				totalPages = pdfDoc.numPages;
				pageCountEl.textContent = String(totalPages);
				// Determine current file path and restore last page
				currentFilePath = typeof src === 'string' ? src : (src && src.url) || (src && src.filename) || 'blob';
				
				// Save current file to localStorage
				if (typeof src === 'string') {
					saveLastFile(src);
				}
				
				let startPage = 1;
				if (!resetToPage1) {
					// Only restore saved page if not resetting
					let savedPage = null;
					try { savedPage = localStorage.getItem('pdf_last_page'); } catch {}
					startPage = savedPage ? Math.max(1, Math.min(parseInt(savedPage, 10) || 1, pdfDoc.numPages)) : 1;
				}
				
				currentPageNumber = startPage;
				pageNumberInput.value = String(startPage);
				updateButtons();
				updateBookmarkUI(); // Update bookmark button state
				await renderPage(startPage);
			}


			function saveLastFile(path) {
				try {
					localStorage.setItem(LAST_FILE_KEY, path);
				} catch (err) {
					console.log('Could not save last file to localStorage:', err);
				}
			}

			function getLastFile() {
				try {
					return localStorage.getItem(LAST_FILE_KEY);
				} catch (err) {
					console.log('Could not get last file from localStorage:', err);
					return null;
				}
			}

			// UI events - Simple approach
			prevBtn.onclick = function(e) {
				alert('Previous clicked!');
				console.log('=== PREVIOUS BUTTON CLICKED ===');
				
				if (lessonSelect && lessonSelect.value === 'bookmarks') {
					console.log('Bookmark mode - calling goToPrevBookmark()');
					goToPrevBookmark();
				} else {
					console.log('Normal mode - calling goToPage()');
					goToPage(currentPageNumber - 1);
				}
			};
			nextBtn.onclick = function(e) {
				alert('Next clicked!');
				console.log('=== NEXT BUTTON CLICKED ===');
				
				if (lessonSelect && lessonSelect.value === 'bookmarks') {
					console.log('Bookmark mode - calling goToNextBookmark()');
					goToNextBookmark();
				} else {
					console.log('Normal mode - calling normal next page logic');
					if (randomCheckbox && randomCheckbox.checked) {
						// Random page when checkbox is checked
						const randomPage = Math.floor(Math.random() * totalPages) + 1;
						goToPage(randomPage);
					} else {
						// Normal next page
						goToPage(currentPageNumber + 1);
					}
				}
			};
			pageNumberInput.addEventListener('change', () => {
				const val = parseInt(pageNumberInput.value, 10);
				if (!Number.isNaN(val)) {
					// Check if we're in bookmark lesson mode
					if (lessonSelect && lessonSelect.value === 'bookmarks') {
						if (val >= 1 && val <= bookmarkLessonData.length) {
							currentBookmarkIndex = val - 1;
							loadCurrentBookmark();
						}
					} else {
						goToPage(val);
					}
				}
			});
			function setZoomPercent(percent) {
				// Save current scroll ratio before changing zoom
				saveScrollPosition();
				const clamped = Math.max(25, Math.min(percent, 400));
				zoomInput.value = String(clamped);
				zoom = clamped / 100;
				try { localStorage.setItem(ZOOM_STORAGE_KEY, String(clamped)); } catch {}
				queueRender(currentPageNumber);
			}
			zoomInput.addEventListener('change', () => {
				const val = parseInt(zoomInput.value, 10);
				if (!Number.isNaN(val)) setZoomPercent(val);
			});
			// Update overlays when range changes
			if (rangeSelect) {
				rangeSelect.addEventListener('change', () => { saveRangeSelection(); queueRender(currentPageNumber); });
			}
			// Save random checkbox state when changed
			if (randomCheckbox) {
				randomCheckbox.addEventListener('change', saveRandomCheckbox);
			}

			// Bookmark event listeners
			if (bookmarkBtn) {
				bookmarkBtn.addEventListener('click', () => {
					if (isBookmarked(currentPageNumber)) {
						removeBookmark(currentPageNumber);
					} else {
						addBookmark(currentPageNumber);
					}
				});
			}

			if (bookmarkListBtn && bookmarkMenu) {
				bookmarkListBtn.addEventListener('click', () => {
					const isVisible = bookmarkMenu.style.display === 'block';
					bookmarkMenu.style.display = isVisible ? 'none' : 'block';
					if (!isVisible) {
						renderBookmarkList();
					}
				});

				// Close dropdown when clicking outside
				document.addEventListener('click', (e) => {
					if (!bookmarkDropdown.contains(e.target)) {
						bookmarkMenu.style.display = 'none';
					}
				});
			}

			// Save lesson selection when changed
			if (lessonSelect) {
				lessonSelect.addEventListener('change', saveLessonSelection);
			}
			// Preserve scroll on zoom change by saving before and restoring after render
			zoomInput.addEventListener('focus', () => { saveScrollPosition(); });

			document.addEventListener('keydown', (e) => {
				if (!pdfDoc) return;
				if (e.key === 'ArrowRight') {
					console.log('Right arrow pressed');
					if (lessonSelect && lessonSelect.value === 'bookmarks') {
						console.log('Bookmark mode - calling goToNextBookmark()');
						goToNextBookmark();
					} else {
						console.log('Normal mode - calling goToNextPage()');
						goToNextPage();
					}
				} else if (e.key === 'ArrowLeft') {
					console.log('Left arrow pressed');
					if (lessonSelect && lessonSelect.value === 'bookmarks') {
						console.log('Bookmark mode - calling goToPrevBookmark()');
						goToPrevBookmark();
					} else {
						console.log('Normal mode - calling goToPage()');
						goToPage(currentPageNumber - 1);
					}
				}
			});

			openBtn.addEventListener('click', () => fileInput.click());
			fileInput.addEventListener('change', () => {
				const file = fileInput.files && fileInput.files[0];
				if (!file) return;
				const reader = new FileReader();
				reader.onload = () => {
					const buffer = new Uint8Array(reader.result);
					// Save uploaded file name to localStorage
					saveLastFile('uploaded:' + file.name);
					loadPdf({ data: buffer, filename: file.name });
				};
				reader.readAsArrayBuffer(file);
			});

			// Populate lessonSelect 1..50 + Bookmarks
			(function initLessonSelect() {
				// Add Bookmarks option first
				const bookmarksOption = document.createElement('option');
				bookmarksOption.value = 'bookmarks';
				bookmarksOption.textContent = '📚 Bookmarks';
				lessonSelect.appendChild(bookmarksOption);
				
				// Add vocabulary lessons
				for (let i = 1; i <= 50; i++) {
					const option = document.createElement('option');
					option.value = String(i);
					option.textContent = 'vocabulary-' + i;
					lessonSelect.appendChild(option);
				}
				lessonSelect.addEventListener('change', () => {
					const value = lessonSelect.value;
					
					if (value === 'bookmarks') {
						// Handle bookmarks selection
						loadBookmarksLesson();
					} else {
						const idx = parseInt(value, 10);
						if (!Number.isNaN(idx)) {
							const path = 'storage/japan/vocabulary-' + idx + '.pdf';
							saveLastFile(path);
							// Load PDF first to get total pages, then check if random is enabled
							loadPdf(path, true).then(() => {
								// Only go to random page if checkbox is checked
								if (randomCheckbox && randomCheckbox.checked) {
									const randomPage = Math.floor(Math.random() * totalPages) + 1;
									try { localStorage.setItem('pdf_last_page', String(randomPage)); } catch {}
									goToPage(randomPage);
								}
								// If random is not checked, stay on page 1 (already loaded by loadPdf with resetToPage1=true)
							}).catch(() => {/* handled below on canvas message if needed */});
						}
					}
				});
			})();

			// Auto load from localStorage or default sample
			const lastFile = getLastFile();
			const defaultFile = 'storage/japan/vocabulary-1.pdf';
			const initial = lastFile || defaultFile;
			// Restore zoom from storage before first render
			(function restoreZoom() {
				let saved = null;
				try { saved = localStorage.getItem(ZOOM_STORAGE_KEY); } catch {}
				const percent = saved ? parseInt(saved, 10) : 100;
				if (!Number.isNaN(percent)) {
					zoomInput.value = String(percent);
					zoom = percent / 100;
				}
			})();
			// Restore range selection before first render
			restoreRangeSelection();
			// Restore random checkbox state
			restoreRandomCheckbox();
			// Restore lesson selection first
			restoreLessonSelection();
			// Then reflect initial into lessonSelect if it matches vocabulary-N (only if no saved selection)
			(function syncLessonFromInitial(path) {
				const saved = localStorage.getItem(LESSON_SELECT_KEY);
				// Only override if no saved selection
				if (!saved) {
					const match = /vocabulary-(\d+)\.pdf$/i.exec(path || '');
					if (match) {
						lessonSelect.value = String(parseInt(match[1], 10));
					} else if (path === 'bookmarks') {
						lessonSelect.value = 'bookmarks';
					}
				}
			})(initial);
			// Restore cover toggle
			(function restoreCover() {
				let v = null;
				try { v = localStorage.getItem(GUIDE_COVER_KEY); } catch {}
			})();
			// Only load PDF if not in bookmark lesson mode
			if (lessonSelect.value !== 'bookmarks') {
				loadPdf(initial).catch(err => {
					console.error('Không thể tải PDF:', err);
					// Show a friendly message on canvas
					const msg = 'Không thể mở PDF. Hãy dùng nút Mở PDF hoặc ?file=...';
					canvas.width = 900; canvas.height = 200;
					ctx.fillStyle = '#ffffff';
					ctx.fillRect(0,0,canvas.width,canvas.height);
					ctx.fillStyle = '#111';
					ctx.font = '20px Segoe UI, Roboto, Arial';
					ctx.fillText(msg, 20, 80);
				});
			}
		})();
	</script>
</body>
</html>


